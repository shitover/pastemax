This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.cursor-tasks.md
.eslintrc.cjs
.repomixignore
build.js
dev.js
docker-compose.yml
Dockerfile
excluded-files.js
index.html
main.js
package.json
preload.js
public/favicon.svg
renderer.js
src/App.tsx
src/assets/favicon.svg
src/components/CopyButton.tsx
src/components/FileCard.tsx
src/components/FileList.tsx
src/components/SearchBar.tsx
src/components/Sidebar.tsx
src/components/ThemeToggle.tsx
src/components/TreeItem.tsx
src/components/UserInstructions.tsx
src/context/ThemeContext.tsx
src/declarations.d.ts
src/index.html
src/main.tsx
src/react-app-env.d.ts
src/styles/index.css
src/types/FileTypes.ts
src/utils/pathUtils.ts
tsconfig.json
tsconfig.node.json
vite.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".repomixignore">
# Add patterns to ignore here, one per line
# Example:
# *.log
# tmp/

release-builds/*
node_modules/*
docs/*
dist/*
scripts/*
.git/*
.github/*

KnownIssue.md
CHANGELOG.md
commit-message.txt
CONTRIBUTING.md
LICENSE
README.docker.md
README.md
RELEASE.md
repomix.config.json
.repoignore
.gitignore
</file>

<file path=".cursor-tasks.md">
# **Implementation Checklist**

## **Story 1: Project Setup and Basic Electron App**

### **Goal:**

Initialize the project, set up Electron, and confirm that a basic window can be displayed.

- [x] **1.2 Initialize Node.js Project**

  - [x] In a terminal, navigate to the project directory.
  - [x] Run `npm init -y` to create a `package.json` file with default settings.

- [x] **1.3 Install Electron**

  - [x] Run `npm install electron --save-dev` (or `--save`) to add Electron as a dev dependency.

- [x] **1.4 Create Main Process File**

  - [x] Create a new file named `main.js` in the project root directory.

- [x] **1.5 Add Basic Electron Boilerplate to `main.js`**

  - [x] Import `app` and `BrowserWindow` from `electron`:
    ```js
    const { app, BrowserWindow } = require("electron");
    ```
  - [x] Create a function `createWindow()` that instantiates a `BrowserWindow`:

    ```js
    function createWindow() {
      const mainWindow = new BrowserWindow({
        width: 800,
        height: 600,
        webPreferences: {
          nodeIntegration: true, // or false if using a more secure setup
          contextIsolation: false, // depends on security preference
        },
      });

      mainWindow.loadFile("index.html");
    }
    ```

  - [x] In `app.whenReady()`, call `createWindow()`:

    ```js
    app.whenReady().then(() => {
      createWindow();

      app.on("activate", () => {
        if (BrowserWindow.getAllWindows().length === 0) createWindow();
      });
    });
    ```

  - [x] Handle `window-all-closed` to quit on platforms other than macOS:
    ```js
    app.on("window-all-closed", () => {
      if (process.platform !== "darwin") {
        app.quit();
      }
    });
    ```

- [x] **1.6 Create Renderer Process File - `index.html`**

  - [x] In the project root, create `index.html`.

- [x] **1.7 Basic HTML Structure**

  - [x] Add the minimal tags to `index.html`:
    ```html
    <!DOCTYPE html>
    <html>
      <head>
        <meta charset="UTF-8" />
        <title>Repo String Clone</title>
      </head>
      <body>
        <h1>Repo String Clone</h1>
        <!-- Additional UI elements will be added later -->
      </body>
    </html>
    ```

- [x] **1.8 Load HTML in Main Process**

  - [x] Confirm `main.js` calls `mainWindow.loadFile('index.html')` inside `createWindow()`. (Already in step 1.5)

- [x] **1.9 Add Start Script in `package.json`**

  - [x] Open `package.json`.
  - [x] Add a script named `"start"` with the command `"electron ."`:
    ```json
    "scripts": {
      "start": "electron ."
    }
    ```

- [x] **1.10 Test Basic App**
  - [x] Run `npm start`.
  - [x] Ensure the Electron app launches with a blank (or basic) window titled "Repo String Clone".

---

## **Story 2: Folder Selection**

### **Goal:**

Allow the user to open a folder dialog, select a directory, and store/return the path.

- [x] **2.1 Add "Open Folder" Button (HTML)**

  - [x] In `index.html`, in the `<body>`, add:
    ```html
    <button id="open-folder-button">Open Folder</button>
    <div id="selected-folder-display"></div>
    ```

- [x] **2.2 Create `renderer.js` (Renderer Script)**

  - [x] Create a file named `renderer.js` in the project root (or a `src/` directory).
  - [x] Link it in `index.html` by adding:
    ```html
    <script src="./renderer.js"></script>
    ```

- [x] **2.3 Import IPC in Renderer**

  - [x] In `renderer.js`, add:
    ```js
    const { ipcRenderer } = require("electron");
    ```

- [x] **2.4 Button Click Handler**

  - [x] Still in `renderer.js`, get a reference to the button and attach an event listener:
    ```js
    const openFolderButton = document.getElementById("open-folder-button");
    openFolderButton.addEventListener("click", () => {
      ipcRenderer.send("open-folder");
    });
    ```

- [x] **2.5 Handle IPC in Main Process**

  - [x] In `main.js`, import `ipcMain` and `dialog`:
    ```js
    const { ipcMain, dialog } = require("electron");
    ```
  - [x] Listen for the `'open-folder'` message:

    ```js
    ipcMain.on("open-folder", async (event) => {
      const result = await dialog.showOpenDialog({
        properties: ["openDirectory"],
      });

      if (!result.canceled && result.filePaths && result.filePaths.length > 0) {
        const selectedPath = result.filePaths[0];
        event.sender.send("folder-selected", selectedPath);
      }
    });
    ```

- [x] **2.6 Receive Path in Renderer**

  - [x] In `renderer.js`, listen for `'folder-selected'`:

    ```js
    ipcRenderer.on("folder-selected", (event, selectedPath) => {
      // Store or display the selected path
      const selectedFolderDisplay = document.getElementById(
        "selected-folder-display",
      );
      selectedFolderDisplay.textContent = `Selected Folder: ${selectedPath}`;

      // Additional logic to request file listing, etc., can go here
    });
    ```

- [x] **2.7 Verify Folder Selection Flow**
  - [x] Launch the app (`npm start`).
  - [x] Click **Open Folder**, choose a directory, and ensure the path appears in `selected-folder-display`.

---

## **Story 3: File Listing (Basic)**

### **Goal:**

Display a list of files (non-recursive) from the selected folder.

> **Note:** We will soon switch to a recursive listing in Story 4. For now, a single-level read is fine.

- [x] **3.1 Create File List Container (HTML)**

  - [x] In `index.html`, add a container for file entries:
    ```html
    <ul id="file-list"></ul>
    ```

- [x] **3.2 Extend IPC Flow for File List Request**

  - [x] In `renderer.js`, when folder is selected (`'folder-selected'` event), also send a message to the main process requesting file data:

    ```js
    ipcRenderer.on("folder-selected", (event, selectedPath) => {
      // Display selected path
      document.getElementById(
        "selected-folder-display",
      ).textContent = `Selected Folder: ${selectedPath}`;

      // Request file list data
      ipcRenderer.send("request-file-list", selectedPath);
    });
    ```

- [x] **3.3 In Main Process, Listen for `request-file-list`**

  - [x] In `main.js`, add:

    ```js
    const fs = require("fs");
    const path = require("path");

    ipcMain.on("request-file-list", (event, folderPath) => {
      try {
        const dirents = fs.readdirSync(folderPath, { withFileTypes: true });
        // Filter for files
        const files = dirents
          .filter((dirent) => dirent.isFile())
          .map((dirent) => {
            return {
              name: dirent.name,
              path: path.join(folderPath, dirent.name),
            };
          });

        event.sender.send("file-list-data", files);
      } catch (err) {
        console.error("Error reading directory:", err);
        event.sender.send("file-list-data", []); // or send an error message
      }
    });
    ```

- [x] **3.4 Render File List in Renderer**

  - [x] In `renderer.js`, add:

    ```js
    ipcRenderer.on("file-list-data", (event, files) => {
      const fileList = document.getElementById("file-list");
      // Clear existing list
      fileList.innerHTML = "";

      files.forEach((file) => {
        const li = document.createElement("li");
        li.textContent = file.name;
        fileList.appendChild(li);
      });
    });
    ```

- [x] **3.5 Test Basic File Listing**
  - [x] Launch the app, open a folder with a few files, and ensure file names appear.
  - [x] Confirm no subfolder files are listed yet (that's expected at this stage).

---

## **Story 4: Recursive File Listing**

### **Goal:**

Recursively list files from the selected folder and all subfolders.

- [x] **4.1 Create Recursive Function in Main Process**

  - [x] In `main.js`, define a function (e.g., `readFilesRecursively`) that accepts a directory path and returns an array of file info objects.
    ```js
    function readFilesRecursively(dir) {
      let results = [];
      const dirents = fs.readdirSync(dir, { withFileTypes: true });
      dirents.forEach((dirent) => {
        const fullPath = path.join(dir, dirent.name);
        if (dirent.isDirectory()) {
          // Recursively read subdirectory
          results = results.concat(readFilesRecursively(fullPath));
        } else if (dirent.isFile()) {
          // Add file info
          results.push({
            name: dirent.name,
            path: fullPath,
          });
        }
      });
      return results;
    }
    ```

- [x] **4.2 Integrate Recursive Function into IPC**

  - [x] Replace the previous `fs.readdirSync` logic in `ipcMain.on('request-file-list', ...)` with the recursive version:
    ```js
    ipcMain.on("request-file-list", (event, folderPath) => {
      try {
        const files = readFilesRecursively(folderPath);
        event.sender.send("file-list-data", files);
      } catch (err) {
        console.error("Error reading directory:", err);
        event.sender.send("file-list-data", []);
      }
    });
    ```

- [x] **4.3 Test Recursive Listing**
  - [x] Open a directory with nested subfolders and confirm that _all_ files from subfolders appear in the list.

---

## **Story 5: File Selection (Checkboxes)**

### **Goal:**

Allow the user to select multiple files via checkboxes, with "Select All" and "Deselect All" functionality.

- [x] **5.1 Add Checkboxes to File List**

  - [x] In the `'file-list-data'` handler in `renderer.js`, modify the `forEach` to create a checkbox:

    ```js
    files.forEach((file) => {
      const li = document.createElement("li");

      const checkbox = document.createElement("input");
      checkbox.type = "checkbox";
      checkbox.value = file.path; // or use dataset
      checkbox.addEventListener("change", handleCheckboxChange);

      const label = document.createElement("span");
      label.textContent = file.name;

      li.appendChild(checkbox);
      li.appendChild(label);
      fileList.appendChild(li);
    });
    ```

- [x] **5.2 Maintain a `selectedFiles` Array in `renderer.js`**

  - [x] Create a top-level array:
    ```js
    let selectedFiles = [];
    ```
  - [x] Create a handler function:
    ```js
    function handleCheckboxChange(event) {
      const filePath = event.target.value;
      if (event.target.checked) {
        if (!selectedFiles.includes(filePath)) {
          selectedFiles.push(filePath);
        }
      } else {
        selectedFiles = selectedFiles.filter((path) => path !== filePath);
      }
    }
    ```

- [x] **5.3 Add "Select All" / "Deselect All" Buttons (HTML)**

  - [x] In `index.html`, add:
    ```html
    <button id="select-all-button">Select All</button>
    <button id="deselect-all-button">Deselect All</button>
    ```

- [x] **5.4 Implement "Select All"**

  - [x] In `renderer.js`, reference the buttons:
    ```js
    const selectAllButton = document.getElementById("select-all-button");
    const deselectAllButton = document.getElementById("deselect-all-button");
    ```
  - [x] Add event listener for select all:
    ```js
    selectAllButton.addEventListener("click", () => {
      const checkboxes = document.querySelectorAll(
        '#file-list input[type="checkbox"]',
      );
      selectedFiles = [];
      checkboxes.forEach((checkbox) => {
        checkbox.checked = true;
        selectedFiles.push(checkbox.value);
      });
    });
    ```

- [x] **5.5 Implement "Deselect All"**

  - [x] Add event listener for deselect all:
    ```js
    deselectAllButton.addEventListener("click", () => {
      const checkboxes = document.querySelectorAll(
        '#file-list input[type="checkbox"]',
      );
      checkboxes.forEach((checkbox) => {
        checkbox.checked = false;
      });
      selectedFiles = [];
    });
    ```

- [x] **5.6 Test File Selection**
  - [x] Check/uncheck individual boxes and confirm `selectedFiles` updates.
  - [x] Click "Select All" / "Deselect All" and confirm the UI and `selectedFiles` state matches.

---

## **Story 6: Token Estimation (Basic)**

### **Goal:**

Estimate tokens per file using a tokenization library (e.g., `gpt-3-encoder`), store the token count in file data, and display it.

- [x] **6.1 Choose and Install Token Estimator**

  - [x] Run `npm install gpt-3-encoder` (or your chosen library).

- [x] **6.2 Read File Content in Main Process**

  - [x] In `readFilesRecursively`, after identifying a file, read its content:
    ```js
    const fileContent = fs.readFileSync(fullPath, "utf8");
    ```
  - [x] Store `fileContent` in a local variable (e.g., `content`).

- [x] **6.3 Estimate Tokens**

  - [x] Import `encode` from `gpt-3-encoder` at the top of `main.js`:
    ```js
    const { encode } = require("gpt-3-encoder");
    ```
  - [x] Calculate token length:
    ```js
    const encoded = encode(fileContent);
    const tokenCount = encoded.length;
    ```
  - [x] Attach `tokenCount` to the results array's item object (including the file path and content):
    ```js
    results.push({
      name: dirent.name,
      path: fullPath,
      content: fileContent,
      tokenCount: tokenCount,
    });
    ```

- [x] **6.4 Send Token Count to Renderer**

  - [x] Ensure the final array includes `tokenCount` for each file.

- [x] **6.5 Display Token Count in Renderer**

  - [x] In `ipcRenderer.on('file-list-data', ...)`, when creating the list item, also show `tokenCount`:
    ```js
    const tokenCountSpan = document.createElement("span");
    tokenCountSpan.textContent = ` (Tokens: ${file.tokenCount})`;
    // ...
    li.appendChild(tokenCountSpan);
    ```

- [x] **6.6 Test Token Estimation**
  - [x] Open a folder with some files, confirm tokens appear.
  - [x] Validate approximate accuracy with a known sample (e.g., small text file).

---

## **Story 7: Total Token Count Display**

### **Goal:**

Show the total tokens of _selected_ files in the UI, updating as selection changes.

- [x] **7.1 Add "Total Tokens" Display (HTML)**

  - [x] In `index.html`, add:
    ```html
    <div id="total-tokens">Total Tokens: 0</div>
    ```

- [x] **7.2 Create a `calculateTotalTokens` Function (Renderer)**

  - [x] In `renderer.js`, define:
    ```js
    function calculateTotalTokens() {
      // files is the full array of file data
      let total = 0;
      selectedFiles.forEach((selectedPath) => {
        const fileData = allFiles.find((f) => f.path === selectedPath);
        if (fileData) {
          total += fileData.tokenCount;
        }
      });
      return total;
    }
    ```

- [x] **7.3 Integrate Calculation into File List Rendering**

  - [x] Modify the `'file-list-data'` handler to store the retrieved `files` in a global variable (e.g. `allFiles`) so we can reference them later:
    ```js
    let allFiles = [];
    ipcRenderer.on("file-list-data", (event, files) => {
      allFiles = files;
      // Render the list...
    });
    ```
  - [x] After rendering the list, call a function `updateTotalTokens()` that sets:
    ```js
    function updateTotalTokens() {
      const totalTokens = calculateTotalTokens(allFiles);
      document.getElementById(
        "total-tokens",
      ).textContent = `Total Tokens: ${totalTokens}`;
    }
    ```

- [x] **7.4 Update Total Tokens on Checkbox Change**

  - [x] In `handleCheckboxChange`, after modifying `selectedFiles`, call `updateTotalTokens()`.

- [x] **7.5 Update Total Tokens on "Select All" / "Deselect All"**

  - [x] In the "Select All" button click handler, after setting `selectedFiles`, call `updateTotalTokens()`.
  - [x] In the "Deselect All" button click handler, after clearing `selectedFiles`, call `updateTotalTokens()`.

- [x] **7.6 Test Total Tokens**
  - [x] Select various files, observe total token count changes.
  - [x] Confirm correctness with small test files.

---

## **Story 8: File Sorting**

### **Goal:**

Allow sorting of files by name, size, or token count, in ascending/descending order.

- [x] **8.1 Get File Size in Main Process**

  - [x] In `readFilesRecursively`, after reading the file content and before pushing the object, get file stats:
    ```js
    const stats = fs.statSync(fullPath);
    const fileSize = stats.size; // in bytes
    ```
  - [x] Add `size: fileSize` to the file object.

- [x] **8.2 Add Sort Controls (HTML)**

  - [x] In `index.html`, add a dropdown or buttons. Example (dropdown):
    ```html
    <select id="sort-dropdown">
      <option value="name-asc">Name (A-Z)</option>
      <option value="name-desc">Name (Z-A)</option>
      <option value="tokens-asc">Tokens (Low-High)</option>
      <option value="tokens-desc">Tokens (High-Low)</option>
      <option value="size-asc">Size (Small-Large)</option>
      <option value="size-desc">Size (Large-Small)</option>
    </select>
    ```

- [x] **8.3 Sort State and Function (Renderer)**

  - [x] In `renderer.js`, maintain a variable `currentSort = 'name-asc'`.
  - [x] Define a function `sortFiles(files, sortValue)`:

    ```js
    function sortFiles(files, sortValue) {
      // sortValue might be something like 'name-asc', 'tokens-desc', etc.
      const [sortKey, sortDir] = sortValue.split("-"); // e.g. 'name', 'asc'

      files.sort((a, b) => {
        let comparison = 0;

        if (sortKey === "name") {
          // compare by name
          comparison = a.name.localeCompare(b.name);
        } else if (sortKey === "tokens") {
          comparison = a.tokenCount - b.tokenCount;
        } else if (sortKey === "size") {
          comparison = a.size - b.size;
        }

        return sortDir === "asc" ? comparison : -comparison;
      });

      return files;
    }
    ```

- [x] **8.4 Re-render File List After Sorting**

  - [x] Modify the `'file-list-data'` handler:
    ```js
    ipcRenderer.on("file-list-data", (event, files) => {
      allFiles = files;
      allFiles = sortFiles(allFiles, currentSort);
      renderFileList(allFiles); // a separate function that builds the UI
      updateTotalTokens();
    });
    ```
  - [x] Where `renderFileList()` is your logic that creates `<li>` elements, etc.

- [x] **8.5 Sort Trigger**

  - [x] In `renderer.js`, reference the sort dropdown:
    ```js
    const sortDropdown = document.getElementById("sort-dropdown");
    sortDropdown.addEventListener("change", (event) => {
      currentSort = event.target.value;
      allFiles = sortFiles(allFiles, currentSort);
      renderFileList(allFiles);
      updateTotalTokens();
    });
    ```

- [x] **8.6 Test Sorting**
  - [x] Confirm the list re-sorts properly by name, token count, and size.
  - [x] Check ascending vs. descending.

---

## **Story 9: Concatenation and Copy to Clipboard**

### **Goal:**

Concatenate the contents of selected files in the sorted order, and let the user copy it to the clipboard.

- [x] **9.1 Add "Copy to Clipboard" Button (HTML)**

  - [x] In `index.html`, add:
    ```html
    <button id="copy-button">Copy to Clipboard</button>
    ```

- [x] **9.2 Concatenate Files in Renderer**

  - [x] Define a function `concatenateSelectedFiles()` in `renderer.js`:

    ```js
    function concatenateSelectedFiles() {
      // ensure we use the sorted, current allFiles array
      let concatenatedString = "";

      // We only want to concatenate the files that are both in `selectedFiles` and `allFiles` (in the correct order).
      allFiles.forEach((file) => {
        if (selectedFiles.includes(file.path)) {
          // optional separator
          concatenatedString += `\n\n// ---- File: ${file.name} ----\n\n`;
          concatenatedString += file.content;
        }
      });

      return concatenatedString;
    }
    ```

- [x] **9.3 Implement Copy to Clipboard**

  - [x] In `renderer.js`, get a reference to `copy-button` and add a click handler:
    ```js
    const copyButton = document.getElementById("copy-button");
    copyButton.addEventListener("click", async () => {
      const finalString = concatenateSelectedFiles();
      try {
        await navigator.clipboard.writeText(finalString);
        // Provide feedback
        copyButton.textContent = "Copied!";
        setTimeout(() => {
          copyButton.textContent = "Copy to Clipboard";
        }, 2000);
      } catch (err) {
        console.error("Failed to copy:", err);
      }
    });
    ```

- [x] **9.4 Test Copy Functionality**
  - [x] Select some files, click "Copy to Clipboard".
  - [x] Paste into a text editor to confirm the correct concatenated content.

---

## **Story 10: File Filtering**

### **Goal:**

Allow users to filter the file list by name/path. The displayed list (and selection states) should reflect the filtered results.

- [x] **10.1 Add a Filter/Search Input (HTML)**

  - [x] In `index.html`, add:
    ```html
    <input
      type="text"
      id="filter-input"
      placeholder="Filter files by name..."
    />
    ```

- [x] **10.2 Maintain Original File Data**

  - [x] In `renderer.js`, use two arrays:
    - `allFiles` — the full, unfiltered set of files.
    - `displayedFiles` — the files currently filtered and sorted.

- [x] **10.3 Filter Logic**

  - [x] Define a function `filterFiles(files, filterText)`:
    ```js
    function filterFiles(files, filterText) {
      const lowerFilter = filterText.toLowerCase();
      return files.filter((file) => {
        // filter by name (or path)
        return (
          file.name.toLowerCase().includes(lowerFilter) ||
          file.path.toLowerCase().includes(lowerFilter)
        );
      });
    }
    ```

- [x] **10.4 Handle Filter Input**

  - [x] In `renderer.js`, get reference to the input and add listener:
    ```js
    const filterInput = document.getElementById("filter-input");
    filterInput.addEventListener("input", () => {
      const filterText = filterInput.value;
      displayedFiles = filterFiles(allFiles, filterText);
      displayedFiles = sortFiles(displayedFiles, currentSort);
      renderFileList(displayedFiles);
      updateTotalTokens();
    });
    ```
  - [x] Where `renderFileList(displayedFiles)` only displays those files.

- [x] **10.5 Update Selections After Filtering**

  - [x] In `renderFileList(files)`, re-create checkboxes. Some selected files may not appear if they're filtered out, but remain in `selectedFiles`.
  - [x] Optionally, you can remove from `selectedFiles` any file not in `files`. For example:
    ```js
    selectedFiles = selectedFiles.filter((selectedPath) =>
      files.some((file) => file.path === selectedPath),
    );
    ```
  - [x] After doing that filtering step, call `updateTotalTokens()` to ensure the total token count is correct.

- [x] **10.6 Test Filtering**
  - [x] Type partial filenames to see the list update in real time.
  - [x] Confirm "Select All"/"Deselect All" still works with filtered results.
  - [x] Confirm total tokens is correct under different filter conditions.

---

# **Final Notes**

1. **Security Considerations**

   - If you enable `nodeIntegration` and `contextIsolation: false`, ensure you're aware of potential security risks. A more secure approach might rely on a preload script or a carefully restricted environment.

2. **Performance Considerations**

   - Reading large directories and large files might be slow. Consider asynchronous `fs.readFile` if necessary.
   - Displaying thousands of files in the UI can also affect performance—virtual scrolling or pagination might be needed for huge repos.

3. **UI Libraries**

   - If the project grows, consider using React, Vue, or Svelte for better state management and reactivity. The above plan works fine for a small to medium application in plain DOM manipulation.

4. **Further Enhancements**
   - Multiple workspace memory
   - Different tokenization modes (e.g., GPT-4, GPT-3.5, etc.)
   - Handling binary files (exclude them or show warnings)
   - Enhanced styling with CSS frameworks

---

**Congratulations!** By following this meticulous checklist, you or an autonomous AI Coding Agent should be able to **fully implement** an open-source, cross-platform Electron application that mirrors (and improves upon) the core functionality of RepoPrompt—providing file listing, selection, token estimation, sorting, filtering, concatenation, and a simple one-click copy to clipboard feature.
</file>

<file path=".eslintrc.cjs">
module.exports = {
  root: true,
  env: { browser: true, es2020: true, node: true },
  extends: [
    "eslint:recommended",
    "plugin:@typescript-eslint/recommended",
    "plugin:react-hooks/recommended",
  ],
  ignorePatterns: ["dist", ".eslintrc.cjs"],
  parser: "@typescript-eslint/parser",
  plugins: ["react-refresh"],
  rules: {
    "react-refresh/only-export-components": [
      "warn",
      { allowConstantExport: true },
    ],
    "@typescript-eslint/no-explicit-any": "off", // During development, allow 'any' type
    "@typescript-eslint/no-unused-vars": "warn",
  },
  settings: {
    react: {
      version: "detect",
    },
  },
};
</file>

<file path="docker-compose.yml">
version: '3'

services:
  pastemax-dev:
    build: .
    volumes:
      - .:/app
    working_dir: /app
    tty: true
    stdin_open: true
    command: bash
</file>

<file path="Dockerfile">
FROM node:22

WORKDIR /app

# Install dependencies
RUN apt-get update && apt-get install -y \
    libgtk-3-0 \
    libnotify-dev \
    libgconf-2-4 \
    libnss3 \
    libxss1 \
    libasound2 \
    libxtst6 \
    xvfb \
    wine64 \
    --no-install-recommends \
    && rm -rf /var/lib/apt/lists/*

# We'll mount the project directory as a volume
# This allows for the build artifacts to be accessible from the host

CMD ["bash"]
</file>

<file path="excluded-files.js">
// List of common files to exclude by default
// Users can still manually select these files if needed
// Paths can include glob patterns (*, **, etc.)

module.exports = {
  // Files to always exclude by default when a folder is first loaded
  excludedFiles: [
    // NPM/Yarn/Node related
    "package-lock.json",
    "yarn.lock",
    "npm-debug.log*",
    "yarn-debug.log*",
    "yarn-error.log*",
    "pnpm-lock.yaml",
    ".npmrc",
    ".yarnrc",
    ".nvmrc",
    "node_modules/**",

    // JavaScript/TypeScript related
    ".eslintrc*",
    ".prettierrc*",
    "tsconfig*.json",
    "*.d.ts",
    "*.min.js",
    "*.map",

    // Python related
    "__pycache__/**",
    "*.pyc",
    "*.pyo",
    "*.pyd",
    ".pytest_cache/**",
    ".coverage",
    ".python-version",
    "venv/**",
    ".venv/**",
    "*.egg-info/**",
    "pip-log.txt",
    "pip-delete-this-directory.txt",

    // Go related
    "go.sum",
    "go.mod",
    "vendor/**",

    // Java related
    "*.class",
    "*.jar",
    "target/**",
    ".gradle/**",

    // Ruby related
    "Gemfile.lock",
    ".bundle/**",

    // PHP related
    "composer.lock",
    "vendor/**",

    // Rust related
    "Cargo.lock",
    "target/**",

    // .NET related
    "bin/**",
    "obj/**",
    "*.suo",
    "*.user",

    // Binary and image files
    "*.jpg",
    "*.jpeg",
    "*.png",
    "*.gif",
    "*.ico",
    "*.webp",
    "*.svg",
    "*.pdf",
    "*.zip",
    "*.tar.gz",
    "*.tgz",
    "*.rar",

    // IDE and editor files
    ".idea/**",
    ".vscode/**",
    "*.swp",
    "*.swo",
    ".DS_Store",

    // Build output
    "dist/**",
    "build/**",
    "out/**",
    ".next/**",

    // Log files
    "logs/**",
    "*.log",

    // Database files
    "*.sqlite",
    "*.db",

    // Environment and secrets
    ".env*",
    ".aws/**",
    "*.pem",
    "*.key",

    // Docker related
    "docker-compose.override.yml",

    // Misc
    ".git/**",
    ".github/**",
    ".gitlab/**",
  ],

  // File extensions to always mark as binary/unselectable
  // The app already has binary detection, but this ensures specific types
  // are always treated as binary regardless of content detection
  binaryExtensions: [
    // Images (including .svg which might not be detected as binary)
    ".svg",
    ".jpg",
    ".jpeg",
    ".png",
    ".gif",
    ".bmp",
    ".tiff",
    ".ico",
    ".webp",

    // Other binary formats
    ".pdf",
    ".doc",
    ".docx",
    ".xls",
    ".xlsx",
    ".ppt",
    ".pptx",
  ],
};
</file>

<file path="index.html">
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>PasteMax</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap"
      rel="stylesheet"
    />
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
</file>

<file path="renderer.js">
// Use the exposed electron API instead of direct require
// const { ipcRenderer } = require("electron");

// Track selected files
let selectedFiles = [];
let allFiles = []; // Store all file data
let displayedFiles = []; // Files after filtering and sorting
let currentSort = "name-asc"; // Default sort
let currentFilter = ""; // Current filter text

const openFolderButton = document.getElementById("open-folder-button");
const selectAllButton = document.getElementById("select-all-button");
const deselectAllButton = document.getElementById("deselect-all-button");
const sortDropdown = document.getElementById("sort-dropdown");
const filterInput = document.getElementById("filter-input");
const copyButton = document.getElementById("copy-button");
const copyStatus = document.getElementById("copy-status");

openFolderButton.addEventListener("click", () => {
  // Use the exposed IPC method from preload.js
  window.electron.send("open-folder");
});

// Set up the IPC listeners using the exposed API
window.electron.receive("folder-selected", (selectedPath) => {
  // Store or display the selected path
  const selectedFolderDisplay = document.getElementById(
    "selected-folder-display",
  );
  selectedFolderDisplay.textContent = `Selected Folder: ${selectedPath}`;

  // Reset selected files when a new folder is selected
  selectedFiles = [];
  allFiles = [];
  displayedFiles = [];

  // Reset filter input
  filterInput.value = "";
  currentFilter = "";

  // Request file list data
  window.electron.send("request-file-list", selectedPath);
});

// Also update the file-list-data listener
window.electron.receive("file-list-data", (files) => {
  // Handle received files data
  allFiles = files;
  applyFiltersAndSort();
});

// Sort the files based on the selected sort option
function sortFiles(files, sortValue) {
  const [sortKey, sortDir] = sortValue.split("-"); // e.g. 'name', 'asc'

  return [...files].sort((a, b) => {
    let comparison = 0;

    if (sortKey === "name") {
      comparison = a.name.localeCompare(b.name);
    } else if (sortKey === "tokens") {
      comparison = a.tokenCount - b.tokenCount;
    } else if (sortKey === "size") {
      comparison = a.size - b.size;
    }

    return sortDir === "asc" ? comparison : -comparison;
  });
}

// Sort dropdown change handler
sortDropdown.addEventListener("change", () => {
  currentSort = sortDropdown.value;
  applyFiltersAndSort();
});

// Filter function to filter files by name or path
function filterFiles(files, filterText) {
  if (!filterText) {
    return files;
  }

  const lowerFilter = filterText.toLowerCase();
  return files.filter((file) => {
    return (
      file.name.toLowerCase().includes(lowerFilter) ||
      file.path.toLowerCase().includes(lowerFilter)
    );
  });
}

// Filter input event handler
filterInput.addEventListener("input", () => {
  currentFilter = filterInput.value;
  applyFiltersAndSort();
});

// Apply both filtering and sorting
function applyFiltersAndSort() {
  // First filter
  displayedFiles = filterFiles(allFiles, currentFilter);
  // Then sort
  displayedFiles = sortFiles(displayedFiles, currentSort);
  // Render the list
  renderFileList(displayedFiles);
}

// Calculate total tokens from selected files
function calculateTotalTokens() {
  let total = 0;

  selectedFiles.forEach((selectedPath) => {
    const fileData = allFiles.find((f) => f.path === selectedPath);
    if (fileData) {
      total += fileData.tokenCount;
    }
  });

  return total;
}

// Update the total tokens display
function updateTotalTokens() {
  const totalTokens = calculateTotalTokens();
  document.getElementById(
    "total-tokens",
  ).textContent = `Total Tokens: ${totalTokens.toLocaleString()}`;
}

// Handle checkbox changes
function handleCheckboxChange(event) {
  const filePath = event.target.value;
  if (event.target.checked) {
    if (!selectedFiles.includes(filePath)) {
      selectedFiles.push(filePath);
    }
  } else {
    selectedFiles = selectedFiles.filter((path) => path !== filePath);
  }
  updateTotalTokens();
  console.log("Selected files:", selectedFiles.length);
}

// Select All button functionality
selectAllButton.addEventListener("click", () => {
  const checkboxes = document.querySelectorAll(
    '#file-list input[type="checkbox"]',
  );

  // Get the paths of all currently displayed files
  const displayedPaths = displayedFiles.map((file) => file.path);

  // Remove any previously selected files that are no longer displayed
  selectedFiles = selectedFiles.filter((path) => displayedPaths.includes(path));

  // Add all currently displayed files
  checkboxes.forEach((checkbox) => {
    checkbox.checked = true;
    const filePath = checkbox.value;
    if (!selectedFiles.includes(filePath)) {
      selectedFiles.push(filePath);
    }
  });

  updateTotalTokens();
  console.log("Selected all displayed files:", selectedFiles.length);
});

// Deselect All button functionality
deselectAllButton.addEventListener("click", () => {
  const checkboxes = document.querySelectorAll(
    '#file-list input[type="checkbox"]',
  );

  // Get the paths of all currently displayed files
  const displayedPaths = displayedFiles.map((file) => file.path);

  // Remove currently displayed files from selection
  selectedFiles = selectedFiles.filter(
    (path) => !displayedPaths.includes(path),
  );

  // Uncheck all displayed checkboxes
  checkboxes.forEach((checkbox) => {
    checkbox.checked = false;
  });

  updateTotalTokens();
  console.log("Deselected all displayed files");
});

// Format file size to be human-readable
function formatFileSize(bytes) {
  if (bytes === 0) return "0 B";

  const units = ["B", "KB", "MB", "GB", "TB"];
  const i = Math.floor(Math.log(bytes) / Math.log(1024));

  return parseFloat((bytes / Math.pow(1024, i)).toFixed(2)) + " " + units[i];
}

// Concatenate selected files
function concatenateSelectedFiles() {
  // Get sorted files (both displayed and not displayed)
  const sortedFiles = sortFiles(allFiles, currentSort);

  // Filter to only include selected files
  const sortedSelectedFiles = sortedFiles.filter((file) =>
    selectedFiles.includes(file.path),
  );

  if (sortedSelectedFiles.length === 0) {
    return "No files selected.";
  }

  let concatenatedString = "";

  sortedSelectedFiles.forEach((file) => {
    concatenatedString += `\n\n// ---- File: ${file.name} ----\n\n`;
    concatenatedString += file.content;
  });

  return concatenatedString;
}

// Copy to clipboard functionality
copyButton.addEventListener("click", async () => {
  const content = concatenateSelectedFiles();

  try {
    await navigator.clipboard.writeText(content);

    // Show the "Copied!" status
    copyStatus.classList.add("visible");

    // Hide the status after 2 seconds
    setTimeout(() => {
      copyStatus.classList.remove("visible");
    }, 2000);

    console.log("Content copied to clipboard");
  } catch (err) {
    console.error("Could not copy content: ", err);
    alert("Failed to copy to clipboard");
  }
});

// Render the file list with the current data and sorting
function renderFileList(files) {
  const fileList = document.getElementById("file-list");
  // Clear existing list
  fileList.innerHTML = "";

  files.forEach((file) => {
    const li = document.createElement("li");

    // Create checkbox
    const checkbox = document.createElement("input");
    checkbox.type = "checkbox";
    checkbox.value = file.path;

    // Don't allow selecting binary or skipped files
    if (file.isBinary || file.isSkipped) {
      checkbox.disabled = true;
    } else {
      checkbox.addEventListener("change", handleCheckboxChange);
      // If this file is in selectedFiles, check the box
      if (selectedFiles.includes(file.path)) {
        checkbox.checked = true;
      }
    }

    // Create label for the filename
    const label = document.createElement("span");
    label.textContent = file.name;

    // Apply styling for binary and skipped files
    if (file.isBinary) {
      li.classList.add("binary-file");
      label.innerHTML = `${file.name} <span class="file-badge binary-badge">${file.fileType}</span>`;
    } else if (file.isSkipped) {
      li.classList.add("skipped-file");
      label.innerHTML = `${file.name} <span class="file-badge error-badge">${file.error}</span>`;
    }

    // Create token count display
    const tokenCountSpan = document.createElement("span");
    if (file.isBinary || file.isSkipped) {
      tokenCountSpan.textContent = " (Tokens: N/A)";
    } else {
      tokenCountSpan.textContent = ` (Tokens: ${file.tokenCount.toLocaleString()})`;
    }
    tokenCountSpan.style.color = "#666";
    tokenCountSpan.style.marginLeft = "10px";

    // Create file size display
    const fileSizeSpan = document.createElement("span");
    fileSizeSpan.textContent = ` (Size: ${formatFileSize(file.size)})`;
    fileSizeSpan.style.color = "#666";
    fileSizeSpan.style.marginLeft = "5px";

    // Add the checkbox and labels to the list item
    li.appendChild(checkbox);
    li.appendChild(label);
    li.appendChild(tokenCountSpan);
    li.appendChild(fileSizeSpan);

    fileList.appendChild(li);
  });
}
</file>

<file path="src/assets/favicon.svg">
<svg xmlns="http://www.w3.org/2000/svg" width="512" height="512" viewBox="0 0 512 512">
  <rect width="512" height="512" rx="50" fill="#4a86e8" />
  <rect x="100" y="150" width="312" height="50" rx="10" fill="white" />
  <rect x="100" y="230" width="312" height="50" rx="10" fill="white" />
  <rect x="100" y="310" width="312" height="50" rx="10" fill="white" />
  <circle cx="140" cy="175" r="15" fill="#ff9900" />
  <circle cx="140" cy="255" r="15" fill="#ff9900" />
  <circle cx="140" cy="335" r="15" fill="#ff9900" />
</svg>
</file>

<file path="src/components/CopyButton.tsx">
import React, { useState } from "react";
import { Copy, Check } from "lucide-react";

interface CopyButtonProps {
  text: string;
  className?: string;
  children?: JSX.Element | string;
}

const CopyButton = ({ text, className = "", children }: CopyButtonProps) => {
  const [copied, setCopied] = useState(false);

  const handleCopy = async () => {
    try {
      await navigator.clipboard.writeText(text);
      setCopied(true);

      // Reset the copied state after 2 seconds
      setTimeout(() => {
        setCopied(false);
      }, 2000);
    } catch (err) {
      console.error("Failed to copy:", err);
    }
  };

  // Add inline styles to ensure no focus outline appears
  const buttonStyle = {
    outline: "none",
  };

  return (
    <button
      type="button"
      className={`${className}`}
      onClick={handleCopy}
      title={copied ? "Copied!" : "Copy to clipboard"}
      style={buttonStyle}
    >
      {copied ? <Check size={16} /> : <Copy size={16} />}
      {children}
    </button>
  );
};

export default CopyButton;
</file>

<file path="src/components/FileCard.tsx">
import React from "react";
import { FileCardProps } from "../types/FileTypes";
import { Plus, X, FileText } from "lucide-react";
import CopyButton from "./CopyButton";

interface FileCardComponentProps {
  file: {
    name: string;
    path: string;
    tokenCount: number;
    content: string;
  };
  isSelected: boolean;
  toggleSelection: (path: string) => void;
}

const FileCard = ({
  file,
  isSelected,
  toggleSelection,
}: FileCardComponentProps) => {
  const { name, path: filePath, tokenCount } = file;

  // Format token count for display
  const formattedTokens = tokenCount.toLocaleString();

  return (
    <div className={`file-card ${isSelected ? "selected" : ""}`}>
      <div className="file-card-header">
        <div className="file-card-icon">
          <FileText size={16} />
        </div>
        <div className="file-card-name monospace">{name}</div>
      </div>
      <div className="file-card-info">
        <div className="file-card-tokens">~{formattedTokens} tokens</div>
      </div>

      <div className="file-card-actions">
        <button
          className="file-card-action"
          onClick={() => toggleSelection(filePath)}
          title={isSelected ? "Remove from selection" : "Add to selection"}
        >
          {isSelected ? <X size={16} /> : <Plus size={16} />}
        </button>
        <CopyButton text={file.content} className="file-card-action">
          {""}
        </CopyButton>
      </div>
    </div>
  );
};

export default FileCard;
</file>

<file path="src/components/SearchBar.tsx">
import React, { useState } from "react";
import { Search, X } from "lucide-react";

interface SearchBarProps {
  searchTerm: string;
  onSearchChange: (term: string) => void;
  placeholder?: string;
}

const SearchBar = ({
  searchTerm,
  onSearchChange,
  placeholder = "Search...",
}: SearchBarProps) => {
  const [isFocused, setIsFocused] = useState(false);

  return (
    <div className={`search-bar ${isFocused ? "focused" : ""}`}>
      <div className="search-icon">
        <Search size={16} />
      </div>
      <input
        type="text"
        className="search-input"
        placeholder={placeholder}
        value={searchTerm}
        onChange={(e) => onSearchChange(e.target.value)}
        onFocus={() => setIsFocused(true)}
        onBlur={() => setIsFocused(false)}
      />
      {searchTerm && (
        <button
          className="search-clear-btn"
          onClick={() => onSearchChange("")}
          aria-label="Clear search"
        >
          <X size={14} />
        </button>
      )}
    </div>
  );
};

export default SearchBar;
</file>

<file path="src/components/ThemeToggle.tsx">
import React from "react";
import { useTheme } from "../context/ThemeContext";
import { Sun, Moon, Monitor } from "lucide-react";

const ThemeToggle = (): JSX.Element => {
  const { theme, setTheme } = useTheme();
  
  return (
    <div className="theme-segmented-control">
      <button
        className={`theme-segment ${theme === "light" ? "active" : ""}`}
        onClick={() => setTheme("light")}
        title="Light Mode"
      >
        <Sun size={16} />
        <span>Light</span>
      </button>
      <button
        className={`theme-segment ${theme === "dark" ? "active" : ""}`}
        onClick={() => setTheme("dark")}
        title="Dark Mode"
      >
        <Moon size={16} />
        <span>Dark</span>
      </button>
      <button
        className={`theme-segment ${theme === "system" ? "active" : ""}`}
        onClick={() => setTheme("system")}
        title="Use System Settings"
      >
        <Monitor size={16} />
        <span>Auto</span>
      </button>
    </div>
  );
};

export default ThemeToggle;
</file>

<file path="src/components/UserInstructions.tsx">
import React from "react";

interface UserInstructionsProps {
  instructions: string;
  setInstructions: (value: string) => void;
}

const UserInstructions = ({
  instructions,
  setInstructions,
}: UserInstructionsProps): JSX.Element => {
  return (
    <>
      <div className="user-instructions-header">
        <label className="content-title" htmlFor="userInstructionsInput">
          User Instructions
        </label>
      </div>
      <div className="user-instructions-container">
        <div className="user-instructions">
          <textarea
            id="userInstructionsInput"
            value={instructions}
            onChange={(e) => setInstructions(e.target.value)}
            placeholder="Enter your instructions here..."
            rows={4}
            style={{
              width: "100%",
              resize: "none",
            }}
          />
        </div>
      </div>
    </>
  );
};

export default UserInstructions;
</file>

<file path="src/declarations.d.ts">
// Type declarations for external modules
declare module "react";
declare module "react-dom/client";
declare module "react/jsx-runtime";
declare module "electron";
declare module "tiktoken";
declare module "ignore";
declare module "gpt-3-encoder";

// Allow importing CSS files
declare module "*.css" {
  const content: { [className: string]: string };
  export default content;
}

// Allow importing various file types
declare module "*.svg" {
  const content: string;
  export default content;
}

declare module "*.png" {
  const content: string;
  export default content;
}

declare module "*.jpg" {
  const content: string;
  export default content;
}
</file>

<file path="src/index.html">
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Repo String</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap"
      rel="stylesheet"
    />
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
</file>

<file path="src/main.tsx">
import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App";
import "./styles/index.css";

ReactDOM.createRoot(document.getElementById("root")!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
);
</file>

<file path="src/react-app-env.d.ts">
/// <reference types="react" />
/// <reference types="react-dom" />

// Add missing TypeScript definitions
declare namespace React {
  interface MouseEvent<T = Element> extends globalThis.MouseEvent {}
  interface ChangeEvent<T = Element> extends Event {}
}
</file>

<file path="src/types/FileTypes.ts">
export interface FileData {
  name: string;
  path: string;
  content: string;
  tokenCount: number;
  size: number;
  isBinary: boolean;
  isSkipped: boolean;
  error?: string;
  fileType?: string;
  excludedByDefault?: boolean;
}

export interface TreeNode {
  id: string;
  name: string;
  path: string;
  type: "file" | "directory";
  children?: TreeNode[];
  isExpanded?: boolean;
  level: number;
  fileData?: FileData;
}

export interface SidebarProps {
  selectedFolder: string | null;
  openFolder: () => void;
  allFiles: FileData[];
  selectedFiles: string[];
  toggleFileSelection: (filePath: string) => void;
  toggleFolderSelection: (folderPath: string, isSelected: boolean) => void;
  searchTerm: string;
  onSearchChange: (term: string) => void;
  selectAllFiles: () => void;
  deselectAllFiles: () => void;
  expandedNodes: Record<string, boolean>;
  toggleExpanded: (nodeId: string) => void;
}

export interface FileListProps {
  files: FileData[];
  selectedFiles: string[];
  toggleFileSelection: (filePath: string) => void;
}

export interface FileCardProps {
  file: FileData;
  isSelected: boolean;
  toggleSelection: (filePath: string) => void;
}

export interface TreeItemProps {
  node: TreeNode;
  selectedFiles: string[];
  toggleFileSelection: (filePath: string) => void;
  toggleFolderSelection: (folderPath: string, isSelected: boolean) => void;
  toggleExpanded: (nodeId: string) => void;
}

export interface SortOption {
  value: string;
  label: string;
}

export interface SearchBarProps {
  searchTerm: string;
  onSearchChange: (term: string) => void;
}

export interface CopyButtonProps {
  onCopy: () => void;
  isDisabled: boolean;
  copyStatus: boolean;
}
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "noFallthroughCasesInSwitch": true,

    /* Additional Options */
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "forceConsistentCasingInFileNames": true
  },
  "include": ["src", "src/declarations.d.ts"],
  "references": [{ "path": "./tsconfig.node.json" }]
}
</file>

<file path="tsconfig.node.json">
{
  "compilerOptions": {
    "composite": true,
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="build.js">
/* eslint-disable @typescript-eslint/no-var-requires */
const { execSync } = require("child_process");
const fs = require("fs");
const path = require("path");

async function main() {
  try {
    console.log("📦 Building React app with Vite...");
    execSync("npm run build", { stdio: "inherit" });
    console.log("✅ React build completed successfully!");

    // Fix the paths in index.html for Electron compatibility
    const indexHtmlPath = path.join(__dirname, "dist", "index.html");
    if (fs.existsSync(indexHtmlPath)) {
      let content = fs.readFileSync(indexHtmlPath, "utf8");

      // Fix asset paths for Electron's file:// protocol
      content = content.replace(/\/assets\//g, "./assets/");
      content = content.replace(/(src|href)=["']\//g, '$1="./');
      content = content.replace(
        /(src|href)=["']\.\.\/assets\//g,
        '$1="./assets/',
      );

      fs.writeFileSync(indexHtmlPath, content);
      console.log(
        "🔄 Updated asset paths in index.html for Electron compatibility",
      );
    }

    console.log(
      "🚀 Build process completed! The app is ready to run with Electron.",
    );

    // Package the app
    console.log("📦 Packaging application...");
    execSync("npm run package", { stdio: "inherit" });
    console.log("✅ Packaging completed!");
  } catch (error) {
    console.error("❌ Build failed:", error.message);
    process.exit(1);
  }
}

main();
</file>

<file path="preload.js">
// Preload script
const { contextBridge, ipcRenderer } = require("electron");

// Helper function to ensure data is serializable
function ensureSerializable(data) {
  if (data === null || data === undefined) {
    return data;
  }

  // Handle primitive types directly
  if (typeof data !== "object") {
    return data;
  }

  // For arrays, map each item
  if (Array.isArray(data)) {
    return data.map(ensureSerializable);
  }

  // For objects, create a new object with serializable properties
  const result = {};
  for (const key in data) {
    if (Object.prototype.hasOwnProperty.call(data, key)) {
      // Skip functions or symbols which are not serializable
      if (typeof data[key] === "function" || typeof data[key] === "symbol") {
        continue;
      }
      // Recursively process nested objects
      result[key] = ensureSerializable(data[key]);
    }
  }
  return result;
}

// Expose protected methods that allow the renderer process to use
// the ipcRenderer without exposing the entire object
contextBridge.exposeInMainWorld("electron", {
  send: (channel, data) => {
    // whitelist channels
    const validChannels = ["open-folder", "request-file-list", "debug-file-selection", "cancel-directory-loading"];
    if (validChannels.includes(channel)) {
      // Ensure data is serializable before sending
      const serializedData = ensureSerializable(data);
      ipcRenderer.send(channel, serializedData);
    }
  },
  receive: (channel, func) => {
    const validChannels = [
      "folder-selected",
      "file-list-data",
      "file-processing-status",
      "startup-mode"
    ];
    if (validChannels.includes(channel)) {
      // Remove any existing listeners to avoid duplicates
      ipcRenderer.removeAllListeners(channel);
      // Add the new listener
      ipcRenderer.on(channel, (event, ...args) => func(...args));
    }
  },
  // For backward compatibility (but still ensure serialization)
  ipcRenderer: {
    send: (channel, data) => {
      const serializedData = ensureSerializable(data);
      ipcRenderer.send(channel, serializedData);
    },
    on: (channel, func) => {
      const wrapper = (event, ...args) => {
        try {
          // Don't pass the event object to the callback, only pass the serialized args
          const serializedArgs = args.map(ensureSerializable);
          func(...serializedArgs); // Only pass the serialized args, not the event
        } catch (err) {
          console.error(`Error in IPC handler for channel ${channel}:`, err);
        }
      };
      ipcRenderer.on(channel, wrapper);
      // Store the wrapper function for removal later
      return wrapper;
    },
    removeListener: (channel, func) => {
      const validChannels = [
        "folder-selected",
        "file-list-data",
        "file-processing-status",
        "startup-mode"
      ];
      if (validChannels.includes(channel)) {
        ipcRenderer.removeListener(channel, (event, ...args) => func(...args));
      }
    },
  },
});
</file>

<file path="src/components/FileList.tsx">
import React from "react";
import { FileListProps, FileData } from "../types/FileTypes";
import FileCard from "./FileCard";
import { arePathsEqual } from "../utils/pathUtils";

const FileList = ({
  files,
  selectedFiles,
  toggleFileSelection,
}: FileListProps) => {
  // Only show files that are in the selectedFiles array and not binary/skipped
  const displayableFiles = files.filter(
    (file: FileData) =>
      selectedFiles.some(selectedPath => arePathsEqual(selectedPath, file.path)) && 
      !file.isBinary && 
      !file.isSkipped,
  );

  return (
    <div className="file-list-container">
      {displayableFiles.length > 0 ? (
        <div className="file-list">
          {displayableFiles.map((file: FileData) => (
            <FileCard
              key={file.path}
              file={file}
              isSelected={true} // All displayed files are selected
              toggleSelection={toggleFileSelection}
            />
          ))}
        </div>
      ) : (
        <div className="file-list-empty">
          {files.length > 0
            ? "No files selected. Select files from the sidebar."
            : "Select a folder to view files"}
        </div>
      )}
    </div>
  );
};

export default FileList;
</file>

<file path="src/components/Sidebar.tsx">
import React, { useState, useEffect } from "react";
import { SidebarProps, TreeNode } from "../types/FileTypes";
import SearchBar from "./SearchBar";
import TreeItem from "./TreeItem";

const Sidebar = ({
  selectedFolder,
  openFolder,
  allFiles,
  selectedFiles,
  toggleFileSelection,
  toggleFolderSelection,
  searchTerm,
  onSearchChange,
  selectAllFiles,
  deselectAllFiles,
  expandedNodes,
  toggleExpanded,
}: SidebarProps) => {
  const [fileTree, setFileTree] = useState<TreeNode[]>([]);
  const [isTreeBuildingComplete, setIsTreeBuildingComplete] = useState(false);
  const [sidebarWidth, setSidebarWidth] = useState(300);
  const [isResizing, setIsResizing] = useState(false);

  // Min and max width constraints
  const MIN_SIDEBAR_WIDTH = 200;
  const MAX_SIDEBAR_WIDTH = 500;

  // Handle mouse down for resizing
  const handleResizeStart = (e: React.MouseEvent<HTMLDivElement>) => {
    e.preventDefault();
    setIsResizing(true);
  };

  // Handle resize effect
  useEffect(() => {
    const handleResize = (e: globalThis.MouseEvent) => {
      if (isResizing) {
        const newWidth = e.clientX;
        if (newWidth >= MIN_SIDEBAR_WIDTH && newWidth <= MAX_SIDEBAR_WIDTH) {
          setSidebarWidth(newWidth);
        }
      }
    };

    const handleResizeEnd = () => {
      setIsResizing(false);
    };

    document.addEventListener("mousemove", handleResize);
    document.addEventListener("mouseup", handleResizeEnd);

    return () => {
      document.removeEventListener("mousemove", handleResize);
      document.removeEventListener("mouseup", handleResizeEnd);
    };
  }, [isResizing]);

  // Build file tree structure from flat list of files
  useEffect(() => {
    if (allFiles.length === 0) {
      setFileTree([]);
      setIsTreeBuildingComplete(false);
      return;
    }

    const buildTree = () => {
      console.log("Building file tree from", allFiles.length, "files");
      setIsTreeBuildingComplete(false);

      try {
        // Create a structured representation using nested objects first
        const fileMap: Record<string, any> = {};

        // First pass: create directories and files
        allFiles.forEach((file) => {
          if (!file.path) return;

          const relativePath =
            selectedFolder && file.path.startsWith(selectedFolder)
              ? file.path
                  .substring(selectedFolder.length)
                  .replace(/^\/|^\\/, "")
              : file.path;

          const parts = relativePath.split(/[/\\]/);
          let currentPath = "";
          let current = fileMap;

          // Build the path in the tree
          for (let i = 0; i < parts.length; i++) {
            const part = parts[i];
            if (!part) continue;

            currentPath = currentPath ? `${currentPath}/${part}` : part;
            
            // Use the original file.path for files to avoid path duplication
            const fullPath = i === parts.length - 1 
              ? file.path // For files, use the original path
              : (selectedFolder 
                  ? `${selectedFolder}/${currentPath}` 
                  : currentPath); // For directories

            if (i === parts.length - 1) {
              // This is a file
              current[part] = {
                id: `node-${fullPath}`,
                name: part,
                path: file.path, // Use the original file path
                type: "file",
                level: i,
                fileData: file,
              };
            } else {
              // This is a directory
              if (!current[part]) {
                current[part] = {
                  id: `node-${fullPath}`,
                  name: part,
                  path: fullPath,
                  type: "directory",
                  level: i,
                  children: {},
                };
              }
              current = current[part].children;
            }
          }
        });

        // Convert the nested object structure to the TreeNode array format
        const convertToTreeNodes = (
          node: Record<string, any>,
          level = 0,
        ): TreeNode[] => {
          return Object.keys(node).map((key) => {
            const item = node[key];

            if (item.type === "file") {
              return item as TreeNode;
            } else {
              const children = convertToTreeNodes(item.children, level + 1);
              const isExpanded =
                expandedNodes[item.id] !== undefined
                  ? expandedNodes[item.id]
                  : true; // Default to expanded if not in state

              return {
                ...item,
                children: children.sort((a, b) => {
                  // Sort directories first
                  if (a.type === "directory" && b.type === "file") return -1;
                  if (a.type === "file" && b.type === "directory") return 1;

                  // Sort files by token count (largest first)
                  if (a.type === "file" && b.type === "file") {
                    const aTokens = a.fileData?.tokenCount || 0;
                    const bTokens = b.fileData?.tokenCount || 0;
                    return bTokens - aTokens;
                  }

                  // Default to alphabetical
                  return a.name.localeCompare(b.name);
                }),
                isExpanded,
              };
            }
          });
        };

        // Convert to proper tree structure
        const treeRoots = convertToTreeNodes(fileMap);

        // Sort the top level (directories first, then by name)
        const sortedTree = treeRoots.sort((a, b) => {
          if (a.type === "directory" && b.type === "file") return -1;
          if (a.type === "file" && b.type === "directory") return 1;

          // Sort files by token count (largest first)
          if (a.type === "file" && b.type === "file") {
            const aTokens = a.fileData?.tokenCount || 0;
            const bTokens = b.fileData?.tokenCount || 0;
            return bTokens - aTokens;
          }

          return a.name.localeCompare(b.name);
        });

        setFileTree(sortedTree);
        setIsTreeBuildingComplete(true);
      } catch (err) {
        console.error("Error building file tree:", err);
        setFileTree([]);
        setIsTreeBuildingComplete(true);
      }
    };

    // Use a timeout to not block UI
    const buildTreeTimeoutId = setTimeout(buildTree, 0);
    return () => clearTimeout(buildTreeTimeoutId);
  }, [allFiles, selectedFolder, expandedNodes]);

  // Apply expanded state as a separate operation when expandedNodes change
  useEffect(() => {
    if (fileTree.length === 0) return;

    // Function to apply expanded state to nodes
    const applyExpandedState = (nodes: TreeNode[]): TreeNode[] => {
      return nodes.map((node: TreeNode): TreeNode => {
        if (node.type === "directory") {
          const isExpanded =
            expandedNodes[node.id] !== undefined
              ? expandedNodes[node.id]
              : true; // Default to expanded if not in state

          return {
            ...node,
            isExpanded,
            children: node.children ? applyExpandedState(node.children) : [],
          };
        }
        return node;
      });
    };

    setFileTree((prevTree: TreeNode[]) => applyExpandedState(prevTree));
  }, [expandedNodes]);

  // Flatten the tree for rendering with proper indentation
  const flattenTree = (nodes: TreeNode[]): TreeNode[] => {
    let result: TreeNode[] = [];

    nodes.forEach((node) => {
      // Add the current node
      result.push(node);

      // If it's a directory and it's expanded, add its children
      if (node.type === "directory" && node.isExpanded && node.children) {
        result = [...result, ...flattenTree(node.children)];
      }
    });

    return result;
  };

  // Filter the tree based on search term
  const filterTree = (nodes: TreeNode[], term: string): TreeNode[] => {
    if (!term) return nodes;

    const lowerTerm = term.toLowerCase();

    // Function to check if a node or any of its children match the search
    const nodeMatches = (node: TreeNode): boolean => {
      // Check if the node name matches
      if (node.name.toLowerCase().includes(lowerTerm)) return true;

      // If it's a file, we're done
      if (node.type === "file") return false;

      // For directories, check if any children match
      if (node.children) {
        return node.children.some(nodeMatches);
      }

      return false;
    };

    // Filter the nodes
    return nodes.filter(nodeMatches).map((node) => {
      // If it's a directory, also filter its children
      if (node.type === "directory" && node.children) {
        return {
          ...node,
          children: filterTree(node.children, term),
          isExpanded: true, // Auto-expand directories when searching
        };
      }
      return node;
    });
  };

  // The final tree to render, filtered and flattened
  const visibleTree = flattenTree(filterTree(fileTree, searchTerm));

  return (
    <div className="sidebar" style={{ width: `${sidebarWidth}px` }}>
      <div className="sidebar-header">
        <div className="sidebar-title">Files</div>
        <div className="sidebar-folder-path">{selectedFolder}</div>
      </div>

      <div className="sidebar-search">
        <SearchBar
          searchTerm={searchTerm}
          onSearchChange={onSearchChange}
          placeholder="Search files..."
        />
      </div>

      <div className="sidebar-actions">
        <button className="sidebar-action-btn" onClick={selectAllFiles}>
          Select All
        </button>
        <button className="sidebar-action-btn" onClick={deselectAllFiles}>
          Deselect All
        </button>
      </div>

      {allFiles.length > 0 ? (
        isTreeBuildingComplete ? (
          <div className="file-tree">
            {visibleTree.length > 0 ? (
              visibleTree.map((node) => (
                <TreeItem
                  key={node.id}
                  node={node}
                  selectedFiles={selectedFiles}
                  toggleFileSelection={toggleFileSelection}
                  toggleFolderSelection={toggleFolderSelection}
                  toggleExpanded={toggleExpanded}
                />
              ))
            ) : (
              <div className="tree-empty">No files match your search.</div>
            )}
          </div>
        ) : (
          <div className="tree-loading">
            <div className="spinner"></div>
            <span>Building file tree...</span>
          </div>
        )
      ) : (
        <div className="tree-empty">No files found in this folder.</div>
      )}

      <div
        className="sidebar-resize-handle"
        onMouseDown={handleResizeStart}
        title="Drag to resize sidebar"
      ></div>
    </div>
  );
};

export default Sidebar;
</file>

<file path="src/context/ThemeContext.tsx">
import React, { createContext, useState, useEffect, useContext } from "react";

type ThemeType = "light" | "dark" | "system";

interface ThemeContextType {
  theme: ThemeType;
  currentTheme: "light" | "dark"; // The actual applied theme
  setTheme: (theme: ThemeType) => void;
}

// Create context with proper typing
const defaultThemeContext: ThemeContextType = {
  theme: "system",
  currentTheme: "light",
  setTheme: () => {},
};

const ThemeContext = createContext(defaultThemeContext);

type ThemeProviderProps = { children: JSX.Element | JSX.Element[] };

export const ThemeProvider = ({ children }: ThemeProviderProps): JSX.Element => {
  // Initialize theme from localStorage or default to "system"
  const [theme, setThemeState] = useState(() => {
    const savedTheme = localStorage.getItem("theme") as ThemeType;
    return savedTheme && ["light", "dark", "system"].includes(savedTheme) ? savedTheme : "system";
  });
  
  const [currentTheme, setCurrentTheme] = useState("light");

  // Function to set theme and save to localStorage
  const setTheme = (newTheme: ThemeType) => {
    setThemeState(newTheme);
    localStorage.setItem("theme", newTheme);
  };

  // Effect to apply the correct theme based on selection or system preference
  useEffect(() => {
    const applyTheme = (themeName: "light" | "dark") => {
      setCurrentTheme(themeName);
      
      if (themeName === "dark") {
        document.body.classList.add("dark-mode");
      } else {
        document.body.classList.remove("dark-mode");
      }
    };
    
    // Check for system preference
    const prefersDark = window.matchMedia("(prefers-color-scheme: dark)").matches;
    
    // Apply theme based on selection or system preference
    if (theme === "system") {
      applyTheme(prefersDark ? "dark" : "light");
    } else {
      applyTheme(theme as "light" | "dark");
    }
    
    // Listen for system preference changes if in auto mode
    const mediaQuery = window.matchMedia("(prefers-color-scheme: dark)");
    
    const handleSystemThemeChange = (e: MediaQueryListEvent) => {
      if (theme === "system") {
        applyTheme(e.matches ? "dark" : "light");
      }
    };
    
    mediaQuery.addEventListener("change", handleSystemThemeChange);
    
    return () => mediaQuery.removeEventListener("change", handleSystemThemeChange);
  }, [theme]);

  return (
    <ThemeContext.Provider value={{ theme, currentTheme, setTheme }}>
      {children}
    </ThemeContext.Provider>
  );
};

// Custom hook to use the theme context
export const useTheme = () => {
  const context = useContext(ThemeContext);
  if (context === undefined) {
    throw new Error("useTheme must be used within a ThemeProvider");
  }
  return context;
};
</file>

<file path="vite.config.ts">
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import path from "path";

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  base: "./", // Relative base path for assets
  build: {
    outDir: "dist",
    emptyOutDir: true,
    sourcemap: true,
  },
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "./src"),
    },
  },
});
</file>

<file path="public/favicon.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="1024" zoomAndPan="magnify" viewBox="0 0 768 767.999994" height="1024" preserveAspectRatio="xMidYMid meet" version="1.0"><defs><filter x="0%" y="0%" width="100%" height="100%" id="da72b799a2"><feColorMatrix values="0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 1 0" color-interpolation-filters="sRGB"/></filter><filter x="0%" y="0%" width="100%" height="100%" id="e844cb8224"><feColorMatrix values="0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0.2126 0.7152 0.0722 0 0" color-interpolation-filters="sRGB"/></filter><image x="0" y="0" width="1024" xlink:href="data:image/png;base64,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YAIAwQQAggkABBMACCYAEEwAIJgAQDABgGACAMEEAIIJAAQTAAgmABBMACCYAEAwAYBgAgDBBACCCQAEEwAIJgAQTAAgmABAMAGAYAIAwQQAggkABBMACCYAEEwAIJgAQDABgGACAMEEAIIJAAQTAAgmABBMACCYAEAwAYBgAgDBBACCCQAEEwAIJgAQTABgOhsMf1gAIJgAQDABgGACAMEEAIIJAAQTAAgmABBMACCYAEAwAYBgAgDBBACCCQAEEwAIJgAQTAAgmABAMAGAYAIAwQQAggkABBMACCYAEEwAIJgAQDABgGACAMEEAIIJAAQTAAgmABBMACCYAEAwAYBgAgDBhgdgoqdVAGNhBwDBBACCCQAEEwAIJgAQTAAgmABAMAGAYAIAwQQAggkABBMACCYAEEwAIJgAQDABgGACAMEEAIIJAAQTAAgmABBMACCYAEAwAYBgAgDBBACCCQAEEwAIJgAQTAAgmABAMAGAYAIAwQQAggkABBMACCYAEEwAIJgAQDABgGACAMEEAIIJAAQTAAgmABBMACCYAEAwAYBgAgDBBACCCQAEEwAIJgAQTAAgmABAMAGAYAIAwQQAggkABBMACCYAEEwAIJgAQDABgGACAMEEAIIJAAQTAAgmABBMACCYAEAwAYBgAgDBBACCDQ/ARE+rAMbCDgCCCQAEEwAIJgAQTAAgmABAMAGAYAIAwQQAggkABBMACCYAEEwAIJgAQDABgGACAMEEAIIJAAQTAAgmABBMACCYAEAwAYBgAgDBBACCCQAEEwAIJgAQTAAgmABAMAGAYAIAwQQAggkABBMACCYAEEwAIJgAQDABgGACAMEEAIIJAAQTAAgmABBMACCYAEAwAYBgAgDBBACCCQAEEwAIJgAQTAAgmABAMAGAYAIAwQQAggkABBMACCYAEEwAIJgAQDABgGACAMEEAIIJAAQTAAgmABBMACCYAEAwAYBgAgDBBACCCQAEEwAIJgAQTAAgmABAMAGAYAIAwQQAggkABBMACCYAEEwAIJgAQDABgGACAMEEAIIJAAQTAAgmABBMACCYAEAwAYBgAgDBBACCCQAEEwAIJgAQTAAgmABAMAGAYAIAwQQAggkABBMACCYAEEwAIJgAQDABgGACAMEEAIIJAAQTAAgmABBMACCYAEAwAYBgAgDBBACCCQAEEwAIJgAQTAAg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" id="ab14e8e1cf" height="1024" preserveAspectRatio="xMidYMid meet"/><mask id="77ce78d43b"><g filter="url(#da72b799a2)"><g filter="url(#e844cb8224)" transform="matrix(0.791016, 0, 0, 0.791016, -20.320103, -20.070099)"><image x="0" y="0" width="1024" xlink:href="data:image/png;base64,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YAIAwQQAggkABBMACCYAEEwAIJgAQDABgGACAMEEAIIJAAQTAAgmABBMACCYAEAwAYBgAgDBBACCCQAEEwAIJgAQTAAgmABAMAGAYAIAwQQAggkABBMACCYAEEwAIJgAQDABgGACAMEEAIIJAAQTAAgmABBMACCYAEAwAYBgAgDBBACCCQAEEwAIJgAQTABgOhsMf1gAIJgAQDABgGACAMEEAIIJAAQTAAgmABBMACCYAEAwAYBgAgDBBACCCQAEEwAIJgAQTAAgmABAMAGAYAIAwQQAggkABBMACCYAEEwAIJgAQDABgGACAMEEAIIJAAQTAAgmABBMACCYAEAwAYBgAgDBhgdgoqdVAGNhBwDBBACCCQAEEwAIJgAQTAAgmABAMAGAYAIAwQQAggkABBMACCYAEEwAIJgAQDABgGACAMEEAIIJAAQTAAgmABBMACCYAEAwAYBgAgDBBACCCQAEEwAIJgAQTAAgmABAMAGAYAIAwQQAggkABBMACCYAEEwAIJgAQDABgGACAMEEAIIJAAQTAAgmABBMACCYAEAwAYBgAgDBBACCCQAEEwAIJgAQTAAgmABAMAGAYAIAwQQAggkABBMACCYAEEwAIJgAQDABgGACAMEEAIIJAAQTAAgmABBMACCYAEAwAYBgAgDBBACCDQ/ARE+rAMbCDgCCCQAEEwAIJgAQTAAgmABAMAGAYAIAwQQAggkABBMACCYAEEwAIJgAQDABgGACAMEEAIIJAAQTAAgmABBMACCYAEAwAYBgAgDBBACCCQAEEwAIJgAQTAAgmABAMAGAYAIAwQQAggkABBMACCYAEEwAIJgAQDABgGACAMEEAIIJAAQTAAgmABBMACCYAEAwAYBgAgDBBACCCQAEEwAIJgAQTAAgmABAMAGAYAIAwQQAggkABBMACCYAEEwAIJgAQDABgGACAMEEAIIJAAQTAAgmABBMACCYAEAwAYBgAgDBBACCCQAEEwAIJgAQTAAgmABAMAGAYAIAwQQAggkABBMACCYAEEwAIJgAQDABgGACAMEEAIIJAAQTAAgmABBMACCYAEAwAYBgAgDBBACCCQAEEwAIJgAQTAAgmABAMAGAYAIAwQQAggkABBMACCYAEEwAIJgAQDABgGACAMEEAIIJAAQTAAgmABBMACCYAEAwAYBgAgDBBACCCQAEEwAIJgAQTAAg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" height="1024" preserveAspectRatio="xMidYMid meet"/></g></g></mask><image x="0" y="0" width="1024" xlink:href="data:image/png;base64,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" id="cb95a44e8c" height="1024" preserveAspectRatio="xMidYMid meet"/></defs><g mask="url(#77ce78d43b)"><g transform="matrix(0.791016, 0, 0, 0.791016, -20.320103, -20.070099)"><image x="0" y="0" width="1024" xlink:href="data:image/png;base64,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" height="1024" preserveAspectRatio="xMidYMid meet"/></g></g></svg>
</file>

<file path="src/utils/pathUtils.ts">
/**
 * Browser-compatible path utilities to replace Node.js path module
 */

/**
 * Normalizes a file path to use forward slashes regardless of operating system
 * This helps with path comparison across different platforms
 * 
 * @param filePath The file path to normalize
 * @returns The normalized path with forward slashes
 */
export function normalizePath(filePath: string): string {
  if (!filePath) return filePath;
  
  // Replace backslashes with forward slashes
  return filePath.replace(/\\/g, '/');
}

/**
 * Detects the operating system
 * 
 * @returns The detected operating system ('windows', 'mac', 'linux', or 'unknown')
 */
export function detectOS(): 'windows' | 'mac' | 'linux' | 'unknown' {
  if (typeof window !== 'undefined' && window.navigator) {
    const platform = window.navigator.platform.toLowerCase();
    
    if (platform.includes('win')) {
      return 'windows';
    } else if (platform.includes('mac')) {
      return 'mac';
    } else if (platform.includes('linux')) {
      return 'linux';
    }
  }
  
  return 'unknown';
}

/**
 * Compares two paths for equality, handling different OS path separators
 * 
 * @param path1 First path to compare
 * @param path2 Second path to compare
 * @returns True if the paths are equivalent, false otherwise
 */
export function arePathsEqual(path1: string, path2: string): boolean {
  return normalizePath(path1) === normalizePath(path2);
}

/**
 * Extract the basename from a path string
 * @param path The path to extract the basename from
 * @returns The basename (last part of the path)
 */
export function basename(path: string | null | undefined): string {
  if (!path) return "";

  // Ensure path is a string
  const pathStr = String(path);

  // Handle both forward and backslashes
  const normalizedPath = pathStr.replace(/\\/g, "/");
  // Remove trailing slashes
  const trimmedPath = normalizedPath.endsWith("/")
    ? normalizedPath.slice(0, -1)
    : normalizedPath;
  // Get the last part after the final slash
  const parts = trimmedPath.split("/");
  return parts[parts.length - 1] || "";
}

/**
 * Extract the directory name from a path string
 * @param path The path to extract the directory from
 * @returns The directory (everything except the last part)
 */
export function dirname(path: string | null | undefined): string {
  if (!path) return ".";

  // Ensure path is a string
  const pathStr = String(path);

  // Handle both forward and backslashes
  const normalizedPath = pathStr.replace(/\\/g, "/");
  // Remove trailing slashes
  const trimmedPath = normalizedPath.endsWith("/")
    ? normalizedPath.slice(0, -1)
    : normalizedPath;
  // Get everything before the final slash
  const lastSlashIndex = trimmedPath.lastIndexOf("/");
  return lastSlashIndex === -1 ? "." : trimmedPath.slice(0, lastSlashIndex);
}

/**
 * Join path segments together
 * @param segments The path segments to join
 * @returns The joined path
 */
export function join(...segments: (string | null | undefined)[]): string {
  return segments
    .filter(Boolean)
    .map((seg) => String(seg))
    .join("/")
    .replace(/\/+/g, "/"); // Replace multiple slashes with a single one
}

/**
 * Get the file extension
 * @param path The path to get the extension from
 * @returns The file extension including the dot
 */
export function extname(path: string | null | undefined): string {
  if (!path) return "";

  const basenameValue = basename(path);
  const dotIndex = basenameValue.lastIndexOf(".");
  return dotIndex === -1 || dotIndex === 0 ? "" : basenameValue.slice(dotIndex);
}

/**
 * Generate an ASCII representation of the file tree for the selected files
 * @param files Array of selected FileData objects
 * @param rootPath The root directory path
 * @returns ASCII string representing the file tree
 */
export function generateAsciiFileTree(files: { path: string }[], rootPath: string): string {
  if (!files.length) return "No files selected.";

  // Normalize the root path for consistent path handling
  const normalizedRoot = rootPath.replace(/\\/g, "/").replace(/\/$/, "");
  
  // Create a tree structure from the file paths
  interface TreeNode {
    name: string;
    isFile: boolean;
    children: Record<string, TreeNode>;
  }
  
  const root: TreeNode = { name: basename(normalizedRoot), isFile: false, children: {} };
  
  // Insert a file path into the tree
  const insertPath = (filePath: string, node: TreeNode) => {
    const normalizedPath = filePath.replace(/\\/g, "/");
    if (!normalizedPath.startsWith(normalizedRoot)) return;
    
    const relativePath = normalizedPath.substring(normalizedRoot.length).replace(/^\//, "");
    if (!relativePath) return;
    
    const pathParts = relativePath.split("/");
    let currentNode = node;
    
    for (let i = 0; i < pathParts.length; i++) {
      const part = pathParts[i];
      const isFile = i === pathParts.length - 1;
      
      if (!currentNode.children[part]) {
        currentNode.children[part] = {
          name: part,
          isFile,
          children: {}
        };
      }
      
      currentNode = currentNode.children[part];
    }
  };
  
  // Insert all files into the tree
  files.forEach(file => insertPath(file.path, root));
  
  // Generate ASCII representation
  const generateAscii = (node: TreeNode, prefix = "", isLast = true, isRoot = true): string => {
    if (!isRoot) {
      let result = prefix;
      result += isLast ? "└── " : "├── ";
      result += node.name;
      result += "\n";
      prefix += isLast ? "    " : "│   ";
      
      const children = Object.values(node.children).sort((a, b) => {
        // Sort by type (directories first) then by name
        if (a.isFile !== b.isFile) {
          return a.isFile ? 1 : -1;
        }
        return a.name.localeCompare(b.name);
      });
      
      return result + children
        .map((child, index) =>
          generateAscii(child, prefix, index === children.length - 1, false)
        )
        .join("");
    } else {
      // Root node special handling
      const children = Object.values(node.children).sort((a, b) => {
        // Sort by type (directories first) then by name
        if (a.isFile !== b.isFile) {
          return a.isFile ? 1 : -1;
        }
        return a.name.localeCompare(b.name);
      });
      
      return children
        .map((child, index) =>
          generateAscii(child, prefix, index === children.length - 1, false)
        )
        .join("");
    }
  };
  
  return generateAscii(root);
}
</file>

<file path="dev.js">
// Check for required dependencies
try {
  // Test loading key dependencies
  require("ignore");
  require("tiktoken");
  require("gpt-3-encoder");
} catch (err) {
  console.error(`\n❌ Missing dependency: ${err.message}`);
  console.error("Please run: npm install\n");
  process.exit(1);
}

const { spawn } = require("child_process");
const { platform } = require("os");

console.log("🚀 Starting development environment...");

// Set environment variable for development mode
process.env.NODE_ENV = "development";

// Default port
let vitePort = 3000;

// Start Vite dev server
console.log("📦 Starting Vite dev server...");
const viteProcess = spawn("npm", ["run", "dev"], {
  stdio: ["inherit", "pipe", "inherit"], // Pipe stdout to capture the port
  shell: platform() === "win32", // Use shell on Windows
});

// Flag to track if Vite has started
let viteStarted = false;

// Listen for Vite server ready message
viteProcess.stdout?.on("data", (data) => {
  const output = data.toString();
  console.log(output); // Echo output to console

  // Extract port from the output (e.g., "Local: http://localhost:3001/")
  const portMatch = output.match(/Local:\s+http:\/\/localhost:(\d+)/);
  if (portMatch && portMatch[1]) {
    vitePort = parseInt(portMatch[1], 10);
    console.log(`🔍 Detected Vite server running on port ${vitePort}`);
  }

  if (output.includes("Local:") && !viteStarted) {
    viteStarted = true;
    startElectron();
  }
});

// Listen for errors that might indicate port conflicts
viteProcess.stderr?.on("data", (data) => {
  const output = data.toString();
  console.error(output); // Echo error output to console

  if (output.includes("Port 3000 is already in use")) {
    console.error(
      "\n❌ Port 3000 is already in use. Try one of the following:",
    );
    console.error(
      "  1. Kill the process using port 3000: 'lsof -i :3000 | grep LISTEN' then 'kill -9 [PID]'",
    );
    console.error("  2. Change the Vite port in vite.config.ts");
    console.error("  3. Restart your computer if the issue persists\n");
  }
});

// Start Electron after a delay if Vite hasn't reported ready
setTimeout(() => {
  if (!viteStarted) {
    console.log(
      "⚠️ Vite server might not be ready yet, but starting Electron anyway...",
    );
    startElectron();
  }
}, 5000); // Wait 5 seconds before attempting to start Electron

function startElectron() {
  console.log(
    `🔌 Starting Electron app with Vite server at port ${vitePort}...`,
  );
  const electronProcess = spawn("npm", ["start"], {
    stdio: "inherit",
    shell: platform() === "win32", // Use shell on Windows
    env: {
      ...process.env,
      NODE_ENV: "development",
      ELECTRON_START_URL: `http://localhost:${vitePort}`,
    },
  });

  electronProcess.on("close", (code) => {
    console.log(`Electron process exited with code ${code}`);
    viteProcess.kill();
    process.exit(code);
  });
}

// Handle process termination
process.on("SIGINT", () => {
  viteProcess.kill();
  process.exit(0);
});

viteProcess.on("close", (code) => {
  console.log(`Vite process exited with code ${code}`);
  process.exit(code);
});
</file>

<file path="main.js">
const { app, BrowserWindow, ipcMain, dialog, globalShortcut } = require("electron");
const fs = require("fs");
const path = require("path");
const os = require("os");

// Global variables for directory loading control
let isLoadingDirectory = false;
let loadingTimeoutId = null;
const MAX_DIRECTORY_LOAD_TIME = 60000; // 60 seconds timeout

// Add handling for the 'ignore' module
let ignore;
try {
  ignore = require("ignore");
  console.log("Successfully loaded ignore module");
} catch (err) {
  console.error("Failed to load ignore module:", err);
  // Simple fallback implementation for when the ignore module fails to load
  ignore = {
    // Simple implementation that just matches exact paths
    createFilter: () => {
      return (path) => !excludedFiles.includes(path);
    },
  };
  console.log("Using fallback for ignore module");
}

/**
 * Normalize file paths to use forward slashes regardless of OS
 * This ensures consistent path formatting between main and renderer processes
 */
function normalizePath(filePath) {
  if (!filePath) return filePath;
  return filePath.replace(/\\/g, '/');
}

/**
 * Get the platform-specific path separator
 */
function getPathSeparator() {
  return os.platform() === 'win32' ? '\\' : '/';
}

// Initialize tokenizer with better error handling
let tiktoken;
try {
  tiktoken = require("tiktoken");
  console.log("Successfully loaded tiktoken module");
} catch (err) {
  console.error("Failed to load tiktoken module:", err);
  tiktoken = null;
}

// Import the excluded files list
const { excludedFiles, binaryExtensions } = require("./excluded-files");

// Initialize the encoder once at startup with better error handling
let encoder;
try {
  if (tiktoken) {
    encoder = tiktoken.get_encoding("o200k_base"); // gpt-4o encoding
    console.log("Tiktoken encoder initialized successfully");
  } else {
    throw new Error("Tiktoken module not available");
  }
} catch (err) {
  console.error("Failed to initialize tiktoken encoder:", err);
  // Fallback to a simpler method if tiktoken fails
  console.log("Using fallback token counter");
  encoder = null;
}

// Binary file extensions that should be excluded from token counting
const BINARY_EXTENSIONS = [
  // Images
  ".jpg",
  ".jpeg",
  ".png",
  ".gif",
  ".bmp",
  ".tiff",
  ".ico",
  ".webp",
  ".svg",
  // Audio/Video
  ".mp3",
  ".mp4",
  ".wav",
  ".ogg",
  ".avi",
  ".mov",
  ".mkv",
  ".flac",
  // Archives
  ".zip",
  ".rar",
  ".tar",
  ".gz",
  ".7z",
  // Documents
  ".pdf",
  ".doc",
  ".docx",
  ".ppt",
  ".pptx",
  ".xls",
  ".xlsx",
  // Compiled
  ".exe",
  ".dll",
  ".so",
  ".class",
  ".o",
  ".pyc",
  // Database
  ".db",
  ".sqlite",
  ".sqlite3",
  // Others
  ".bin",
  ".dat",
].concat(binaryExtensions || []); // Add any additional binary extensions from excluded-files.js

// Max file size to read (5MB)
const MAX_FILE_SIZE = 5 * 1024 * 1024;

function createWindow() {
  // Check if we're starting in safe mode (Shift key pressed)
  const isSafeMode = process.argv.includes('--safe-mode');
  
  const mainWindow = new BrowserWindow({
    width: 1200,
    height: 800,
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: true,
      preload: path.join(__dirname, "preload.js"),
      devTools: {
        isDevToolsExtension: false,
        htmlFullscreen: false,
      },
    },
  });

  // Pass the safe mode flag to the renderer
  mainWindow.webContents.once('did-finish-load', () => {
    mainWindow.webContents.send('startup-mode', { 
      safeMode: isSafeMode 
    });
  });

  // Register the escape key to cancel directory loading
  globalShortcut.register('Escape', () => {
    if (isLoadingDirectory) {
      cancelDirectoryLoading(mainWindow);
    }
  });

  // Clean up shortcuts when window is closed
  mainWindow.on('closed', () => {
    globalShortcut.unregisterAll();
  });

  // Load the index.html file
  if (process.env.NODE_ENV === "development") {
    mainWindow.loadURL("http://localhost:5173");
    mainWindow.webContents.openDevTools();
  } else {
    mainWindow.loadFile(path.join(__dirname, "dist", "index.html"));
  }
}

app.whenReady().then(() => {
  createWindow();

  app.on("activate", () => {
    if (BrowserWindow.getAllWindows().length === 0) createWindow();
  });
});

app.on("window-all-closed", () => {
  if (process.platform !== "darwin") {
    app.quit();
  }
});

// Handle folder selection
ipcMain.on("open-folder", async (event) => {
  const result = await dialog.showOpenDialog({
    properties: ["openDirectory"],
  });

  if (!result.canceled && result.filePaths && result.filePaths.length > 0) {
    const selectedPath = result.filePaths[0];
    try {
      // Ensure we're only sending a string, not an object
      const pathString = String(selectedPath);
      console.log("Sending folder-selected event with path:", pathString);
      event.sender.send("folder-selected", pathString);
    } catch (err) {
      console.error("Error sending folder-selected event:", err);
      // Try a more direct approach as a fallback
      event.sender.send("folder-selected", String(selectedPath));
    }
  }
});

// Function to parse .gitignore file if it exists
function loadGitignore(rootDir) {
  const ig = ignore();
  const gitignorePath = path.join(rootDir, ".gitignore");

  if (fs.existsSync(gitignorePath)) {
    const gitignoreContent = fs.readFileSync(gitignorePath, "utf8");
    ig.add(gitignoreContent);
  }

  // Add some default ignores that are common
  ig.add([".git", "node_modules", ".DS_Store"]);

  // Add the excludedFiles patterns for gitignore-based exclusion
  ig.add(excludedFiles);

  return ig;
}

// Check if file is binary based on extension
function isBinaryFile(filePath) {
  const ext = path.extname(filePath).toLowerCase();
  return BINARY_EXTENSIONS.includes(ext);
}

// Count tokens using tiktoken with o200k_base encoding
function countTokens(text) {
  // Simple fallback implementation if encoder fails
  if (!encoder) {
    return Math.ceil(text.length / 4);
  }

  try {
    // Remove any special tokens that might cause issues
    const cleanText = text.replace(/<\|endoftext\|>/g, '');
    const tokens = encoder.encode(cleanText);
    return tokens.length;
  } catch (err) {
    console.error("Error counting tokens:", err);
    // Fallback to character-based estimation on error
    return Math.ceil(text.length / 4);
  }
}

/**
 * Recursively reads files from a directory with chunked processing and cancellation support.
 * Implements several performance and safety features:
 * - Processes files in small chunks to maintain UI responsiveness
 * - Supports immediate cancellation at any point
 * - Handles binary files and large files appropriately
 * - Respects .gitignore and custom exclusion patterns
 * - Provides progress updates to the UI
 * 
 * @param {string} dir - The directory to process
 * @param {string} rootDir - The root directory (used for relative path calculations)
 * @param {object} ignoreFilter - The ignore filter instance for file exclusions
 * @param {BrowserWindow} window - The Electron window instance for sending updates
 * @returns {Promise<Array>} Array of processed file objects
 */
async function readFilesRecursively(dir, rootDir, ignoreFilter, window) {
  if (!isLoadingDirectory) return [];
  
  rootDir = rootDir || dir;
  ignoreFilter = ignoreFilter || loadGitignore(rootDir);

  let results = [];
  let processedFiles = 0;
  const CHUNK_SIZE = 20;

  try {
    const dirents = await fs.promises.readdir(dir, { withFileTypes: true });
    if (!isLoadingDirectory) return results;

    const directories = dirents.filter(dirent => dirent.isDirectory());
    const files = dirents.filter(dirent => dirent.isFile());

    // Process directories first
    for (const dirent of directories) {
      if (!isLoadingDirectory) return results;

      const fullPath = path.join(dir, dirent.name);
      // Ensure path is relative to root and normalized
      const relativePath = path.relative(rootDir, fullPath).split(path.sep).join('/');

      // Skip PasteMax app directories
      if (fullPath.includes('.app') || fullPath === app.getAppPath()) {
        console.log('Skipping app directory:', fullPath);
        continue;
      }

      // Only check ignore patterns if the path is inside the root directory
      if (!relativePath.startsWith('..') && !ignoreFilter.ignores(relativePath)) {
        const subResults = await readFilesRecursively(fullPath, rootDir, ignoreFilter, window);
        if (!isLoadingDirectory) return results;
        results = results.concat(subResults);
      }

      window.webContents.send("file-processing-status", {
        status: "processing",
        message: `Scanning directories... (Press ESC to cancel)`,
      });
    }

    // Process files in chunks
    for (let i = 0; i < files.length; i += CHUNK_SIZE) {
      if (!isLoadingDirectory) return results;

      const chunk = files.slice(i, i + CHUNK_SIZE);
      
      const chunkPromises = chunk.map(async (dirent) => {
        if (!isLoadingDirectory) return null;

        const fullPath = path.join(dir, dirent.name);
        // Ensure path is relative to root and normalized
        const relativePath = path.relative(rootDir, fullPath).split(path.sep).join('/');

        // Skip files in PasteMax app directories
        if (fullPath.includes('.app') || fullPath === app.getAppPath()) {
          console.log('Skipping app file:', fullPath);
          return null;
        }

        // Only check ignore patterns if the path is inside the root directory
        if (relativePath.startsWith('..')) {
          return null;
        }

        if (ignoreFilter.ignores(relativePath)) {
          return null;
        }

        try {
          const stats = await fs.promises.stat(fullPath);
          if (!isLoadingDirectory) return null;
          
          if (stats.size > MAX_FILE_SIZE) {
            return {
              name: dirent.name,
              path: relativePath,
              tokenCount: 0,
              size: stats.size,
              content: "",
              isBinary: false,
              isSkipped: true,
              error: "File too large to process"
            };
          }

          if (isBinaryFile(fullPath)) {
            return {
              name: dirent.name,
              path: relativePath,
              tokenCount: 0,
              size: stats.size,
              content: "",
              isBinary: true,
              isSkipped: false,
              fileType: path.extname(fullPath).substring(1).toUpperCase()
            };
          }

          const fileContent = await fs.promises.readFile(fullPath, "utf8");
          if (!isLoadingDirectory) return null;
          
          return {
            name: dirent.name,
            path: relativePath,
            content: fileContent,
            tokenCount: countTokens(fileContent),
            size: stats.size,
            isBinary: false,
            isSkipped: false
          };
        } catch (err) {
          console.error(`Error reading file ${fullPath}:`, err);
          return {
            name: dirent.name,
            path: relativePath,
            tokenCount: 0,
            size: 0,
            isBinary: false,
            isSkipped: true,
            error: "Could not read file"
          };
        }
      });

      const chunkResults = await Promise.all(chunkPromises);
      if (!isLoadingDirectory) return results;
      
      results = results.concat(chunkResults.filter(result => result !== null));
      processedFiles += chunk.length;
      
      window.webContents.send("file-processing-status", {
        status: "processing",
        message: `Processing files... ${processedFiles}/${files.length} (Press ESC to cancel)`,
      });
    }
  } catch (err) {
    console.error(`Error reading directory ${dir}:`, err);
    if (err.code === 'EPERM' || err.code === 'EACCES') {
      console.log(`Skipping inaccessible directory: ${dir}`);
      return results;
    }
  }

  return results;
}

// Modify the request-file-list handler to use async/await
ipcMain.on("request-file-list", async (event, folderPath) => {
  // Prevent processing if already loading
  if (isLoadingDirectory) {
    console.log("Already processing a directory, cancelling previous operation");
    cancelDirectoryLoading(BrowserWindow.fromWebContents(event.sender));
    // Wait a bit before starting new operation
    await new Promise(resolve => setTimeout(resolve, 100));
  }

  try {
    // Set the loading flag first to prevent race conditions
    isLoadingDirectory = true;

    // Set up the timeout for directory loading
    setupDirectoryLoadingTimeout(BrowserWindow.fromWebContents(event.sender), folderPath);

    // Send initial progress update
    event.sender.send("file-processing-status", {
      status: "processing",
      message: "Scanning directory structure... (Press ESC to cancel)",
    });

    // Process files with async/await
    const files = await readFilesRecursively(folderPath, folderPath, null, BrowserWindow.fromWebContents(event.sender));
    
    // If loading was cancelled, return early
    if (!isLoadingDirectory) {
      return;
    }

    // Clear the timeout and loading flag
    if (loadingTimeoutId) {
      clearTimeout(loadingTimeoutId);
      loadingTimeoutId = null;
    }
    isLoadingDirectory = false;

    // Update with processing complete status
    event.sender.send("file-processing-status", {
      status: "complete",
      message: `Found ${files.length} files`,
    });

    // Process the files to ensure they're serializable
    const serializedFiles = files.map(file => ({
      path: file.path,
      relativePath: path.relative(folderPath, file.path),
      name: file.name,
      size: file.size,
      isDirectory: file.isDirectory,
      extension: path.extname(file.name).toLowerCase(),
      excluded: shouldExcludeByDefault(file.path, folderPath),
      content: file.content,
      tokenCount: file.tokenCount,
      isBinary: file.isBinary,
      isSkipped: file.isSkipped,
      error: file.error,
    }));

    event.sender.send("file-list-data", serializedFiles);
  } catch (err) {
    console.error("Error processing file list:", err);
    isLoadingDirectory = false;
  
    if (loadingTimeoutId) {
      clearTimeout(loadingTimeoutId);
      loadingTimeoutId = null;
    }
  
    event.sender.send("file-processing-status", {
      status: "error",
      message: `Error: ${err.message}`,
    });
  }
});

// Add handler for cancel-directory-loading event
ipcMain.on("cancel-directory-loading", (event) => {
  cancelDirectoryLoading(BrowserWindow.fromWebContents(event.sender));
});

/**
 * Determines if a file should be excluded based on gitignore patterns and default rules.
 * Normalizes paths for consistent cross-platform behavior.
 * 
 * @param {string} filePath - The full path of the file to check
 * @param {string} rootDir - The root directory for relative path calculation
 * @returns {boolean} True if the file should be excluded
 */
function shouldExcludeByDefault(filePath, rootDir) {
  const relativePath = path.relative(rootDir, filePath).split(path.sep).join('/');
  
  // Don't process paths outside the root directory
  if (relativePath.startsWith('..')) {
    return true;
  }

  const ig = ignore().add(excludedFiles);
  return ig.ignores(relativePath);
}

// Add a debug handler for file selection
ipcMain.on("debug-file-selection", (event, data) => {
  console.log("DEBUG - File Selection:", data);
});

/**
 * Handles the cancellation of directory loading operations.
 * Ensures clean cancellation by:
 * - Clearing all timeouts
 * - Resetting loading flags
 * - Notifying the UI immediately
 * 
 * @param {BrowserWindow} window - The Electron window instance to send updates to
 */
function cancelDirectoryLoading(window) {
  if (!isLoadingDirectory) return;
  
  console.log("Cancelling directory loading process immediately");
  isLoadingDirectory = false;
  
  if (loadingTimeoutId) {
    clearTimeout(loadingTimeoutId);
    loadingTimeoutId = null;
  }
  
  // Send cancellation message immediately
  window.webContents.send("file-processing-status", {
    status: "cancelled",
    message: "Directory loading cancelled",
  });
}

/**
 * Sets up a safety timeout for directory loading operations.
 * Prevents infinite loading by automatically cancelling after MAX_DIRECTORY_LOAD_TIME.
 * 
 * @param {BrowserWindow} window - The Electron window instance
 * @param {string} folderPath - The path being processed (for logging)
 */
function setupDirectoryLoadingTimeout(window, folderPath) {
  // Clear any existing timeout
  if (loadingTimeoutId) {
    clearTimeout(loadingTimeoutId);
  }
  
  // Set a new timeout
  loadingTimeoutId = setTimeout(() => {
    console.log(`Directory loading timed out after ${MAX_DIRECTORY_LOAD_TIME / 1000} seconds: ${folderPath}`);
    cancelDirectoryLoading(window);
  }, MAX_DIRECTORY_LOAD_TIME);
}
</file>

<file path="package.json">
{
  "name": "pastemax",
  "version": "1.1.0",
  "main": "main.js",
  "scripts": {
    "start": "electron .",
    "dev": "vite",
    "dev:electron": "node dev.js",
    "build": "vite build",
    "build-electron": "node build.js",
    "verify-build": "node scripts/verify-build.js",
    "test-build": "node scripts/test-local-build.js",
    "test-build:mac": "node scripts/test-local-build.js mac",
    "test-build:win": "node scripts/test-local-build.js win",
    "test-build:linux": "node scripts/test-local-build.js linux",
    "debug-gh-release": "git tag debug-v$(date +'%Y%m%d%H%M%S') && git push origin --tags",
    "package": "vite build && electron-builder --publish=never",
    "package:mac": "vite build && electron-builder --mac --publish=never",
    "package:win": "vite build && electron-builder --win --publish=never",
    "package:linux": "vite build && electron-builder --linux --publish=never",
    "package:all": "vite build && electron-builder -mwl --publish=never",
    "release": "vite build && electron-builder --publish=onTagOrDraft",
    "lint": "eslint . --ext ts,tsx --report-unused-disable-directives",
    "lint:strict": "eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
    "preview": "vite preview"
  },
  "keywords": [
    "clipboard",
    "code",
    "developer-tools",
    "electron",
    "file-viewer"
  ],
  "author": {
    "name": "kleneway",
    "email": "kleneway@notreal.com"
  },
  "license": "MIT",
  "description": "A modern file viewer application for developers to easily navigate, search, and copy code from repositories.",
  "build": {
    "appId": "com.kleneway.pastemax",
    "productName": "PasteMax",
    "directories": {
      "output": "release-builds"
    },
    "files": [
      "dist/**/*",
      "main.js",
      "preload.js",
      "excluded-files.js",
      "node_modules/**/*"
    ],
    "mac": {
      "category": "public.app-category.developer-tools",
      "icon": "public/favicon.icns",
      "target": [
        "dmg",
        "zip"
      ],
      "hardenedRuntime": false
    },
    "win": {
      "target": [
        "nsis",
        "portable"
      ],
      "icon": "public/favicon.ico"
    },
    "linux": {
      "target": [
        "AppImage",
        "deb",
        "rpm"
      ],
      "category": "Development",
      "icon": "public/favicon.png"
    },
    "asarUnpack": [
      "node_modules/ignore/**",
      "node_modules/tiktoken/**",
      "node_modules/gpt-3-encoder/**"
    ],
    "asar": true,
    "afterSign": "scripts/notarize.js",
    "publish": [
      "github"
    ]
  },
  "devDependencies": {
    "@electron/notarize": "^2.5.0",
    "@types/node": "^20.10.5",
    "@types/react": "^18.2.43",
    "@types/react-dom": "^18.2.17",
    "@typescript-eslint/eslint-plugin": "^6.14.0",
    "@typescript-eslint/parser": "^6.14.0",
    "@vitejs/plugin-react": "^4.2.1",
    "electron": "^34.3.0",
    "electron-builder": "^24.13.3",
    "eslint": "^8.55.0",
    "eslint-plugin-react-hooks": "^4.6.0",
    "eslint-plugin-react-refresh": "^0.4.5",
    "typescript": "^5.3.3",
    "vite": "^5.0.8"
  },
  "dependencies": {
    "gpt-3-encoder": "^1.1.4",
    "ignore": "^7.0.3",
    "lucide-react": "^0.477.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "tiktoken": "^1.0.20"
  }
}
</file>

<file path="src/components/TreeItem.tsx">
import React, { useRef, useEffect } from "react";
import type { MouseEvent, ChangeEvent } from "react";
import { TreeItemProps, TreeNode } from "../types/FileTypes";
import { ChevronRight, File, Folder } from "lucide-react";
import { arePathsEqual } from "../utils/pathUtils";

const TreeItem = ({
  node,
  selectedFiles,
  toggleFileSelection,
  toggleFolderSelection,
  toggleExpanded,
}: TreeItemProps) => {
  const { id, name, path, type, level, isExpanded, fileData } = node;
  const checkboxRef = useRef(null);

  const isSelected =
    type === "file" &&
    selectedFiles.some((selectedPath) => arePathsEqual(selectedPath, path));

  // Recursive function to check if all files in a directory are selected
  const areAllFilesInDirectorySelected = (node: TreeNode): boolean => {
    if (node.type === "file") {
      return selectedFiles.some((selectedPath) =>
        arePathsEqual(selectedPath, node.path),
      );
    }

    if (
      node.type === "directory" &&
      node.children &&
      node.children.length > 0
    ) {
      return node.children.every((child) =>
        areAllFilesInDirectorySelected(child),
      );
    }

    return false;
  };

  // Recursive function to check if any file in a directory is selected
  const isAnyFileInDirectorySelected = (node: TreeNode): boolean => {
    if (node.type === "file") {
      return selectedFiles.some((selectedPath) =>
        arePathsEqual(selectedPath, node.path),
      );
    }

    if (
      node.type === "directory" &&
      node.children &&
      node.children.length > 0
    ) {
      return node.children.some((child) => isAnyFileInDirectorySelected(child));
    }

    return false;
  };

  // For directories, check if all children are selected
  const isDirectorySelected =
    type === "directory" && node.children && node.children.length > 0
      ? areAllFilesInDirectorySelected(node)
      : false;

  // Check if some but not all files in this directory are selected
  const isDirectoryPartiallySelected =
    type === "directory" && node.children && node.children.length > 0
      ? isAnyFileInDirectorySelected(node) && !isDirectorySelected
      : false;

  // Update the indeterminate state manually whenever it changes
  useEffect(() => {
    if (checkboxRef.current) {
      checkboxRef.current.indeterminate = isDirectoryPartiallySelected;
    }
  }, [isDirectoryPartiallySelected]);

  const handleToggle = (e: any) => {
    e.stopPropagation();
    toggleExpanded(id);
  };

  const handleItemClick = (e: any) => {
    if (type === "directory") {
      toggleExpanded(id);
    } else if (type === "file" && !isDisabled) {
      toggleFileSelection(path);
    }
  };

  const handleCheckboxChange = (e: any) => {
    e.stopPropagation();
    if (type === "file") {
      toggleFileSelection(path);
    } else if (type === "directory") {
      toggleFolderSelection(path, e.target.checked);
    }
  };

  // Check if file is binary or otherwise unselectable
  const isDisabled = fileData ? fileData.isBinary || fileData.isSkipped : false;

  // Check if the file is excluded by default (but still selectable)
  const isExcludedByDefault = fileData?.excludedByDefault || false;

  return (
    <div
      className={`tree-item ${isSelected ? "selected" : ""} ${
        isExcludedByDefault ? "excluded-by-default" : ""
      }`}
      style={{ marginLeft: `${level * 16}px` }}
      onClick={handleItemClick}
    >
      {type === "directory" && (
        <div
          className={`tree-item-toggle ${isExpanded ? "expanded" : ""}`}
          onClick={handleToggle}
          aria-label={isExpanded ? "Collapse folder" : "Expand folder"}
        >
          <ChevronRight size={16} />
        </div>
      )}

      {type === "file" && <div className="tree-item-indent"></div>}

      <input
        type="checkbox"
        className="tree-item-checkbox"
        checked={type === "file" ? isSelected : isDirectorySelected}
        ref={checkboxRef}
        onChange={handleCheckboxChange}
        disabled={isDisabled}
        onClick={(e) => e.stopPropagation()}
      />

      <div className="tree-item-content">
        <div className="tree-item-icon">
          {type === "directory" ? <Folder size={16} /> : <File size={16} />}
        </div>

        <div className="tree-item-name">{name}</div>

        {fileData && fileData.tokenCount > 0 && (
          <span className="tree-item-tokens">
            (~{fileData.tokenCount.toLocaleString()})
          </span>
        )}

        {isDisabled && fileData && (
          <span className="tree-item-badge">
            {fileData.isBinary ? "Binary" : "Skipped"}
          </span>
        )}

        {!isDisabled && isExcludedByDefault && (
          <span className="tree-item-badge excluded">Excluded</span>
        )}
      </div>
    </div>
  );
};

export default TreeItem;
</file>

<file path="src/styles/index.css">
:root {
  --background-primary: #ffffff;
  --background-secondary: #f8f8f8;
  --background-selected: rgba(0,0,0,0.06);
  --accent-blue: #0E639C;
  --border-color: #e0e0e0;
  --hover-color: #f5f5f5;
  --text-primary: #000000;
  --text-secondary: #666666;
  --text-disabled: #cccccc;
  --icon-color: #555555;
  --success-color: #2ecc71;
  --warning-color: #f39c12;
  --error-color: #e74c3c;
  --primary-button-background: #000000;
  --primary-button-text: #ffffff;
}

.dark-mode {
  --background-primary: #1E1E1E;
  --background-secondary: #252526;
  --background-selected: #2A2D2E;
  --accent-blue: #0E639C;
  --border-color: #3E3E42;
  --hover-color: #333333;
  --text-primary: #E8E8E8;
  --text-secondary: #BBBBBB;
  --text-disabled: #808080;
  --icon-color: #CCCCCC;
  --success-color: #2ecc71;
  --warning-color: #f39c12;
  --error-color: #e74c3c;
  --primary-button-background: #0E639C;
  --primary-button-text: #ffffff;
}

* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica,
    Arial, sans-serif;
  margin: 0;
  padding: 0;
  background-color: var(--background-primary);
  color: var(--text-primary);
  line-height: 1.5;
  height: 100vh;
  overflow: hidden;
}

#root {
  height: 100vh;
  display: flex;
  flex-direction: column;
}

.app-container {
  display: flex;
  flex-direction: column;
  height: 100%;
  overflow: hidden;
}

button {
  cursor: pointer;
  font-family: inherit;
  border: 1px solid var(--border-color);
  background-color: var(--background-primary);
  font-size: 14px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  padding: 8px 16px;
  border-radius: 4px;
  transition: all 0.2s ease;
  white-space: nowrap;
  font-weight: 500;
  color: var(--text-primary);
}

button:hover {
  background-color: var(--hover-color);
}

button:focus {
  outline: 2px solid var(--accent-blue);
  outline-offset: 1px;
}

button.primary {
  background-color: var(--primary-button-background);
  color: var(--primary-button-text);
  border-color: var(--primary-button-background);
}

button.primary:hover {
  background-color: var(--primary-button-background);
}

button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

input[type="text"],
input[type="search"] {
  padding: 8px 12px;
  border: 1px solid var(--border-color);
  border-radius: 4px;
  font-family: inherit;
  font-size: 14px;
  outline: none;
  width: 100%;
  background-color: var(--background-primary);
  color: var(--text-primary);
}

input[type="text"]:focus,
input[type="search"]:focus {
  border-color: var(--accent-blue);
  box-shadow: 0 0 0 1px var(--accent-blue);
}

.monospace {
  font-family: Consolas, Menlo, Monaco, "Courier New", monospace;
  font-size: 13px;
  line-height: 1.5;
}

/* Main layout structure */
.app-container {
  display: flex;
  flex-direction: column;
  height: 100vh;
}

.header {
  padding: 16px 24px;
  border-bottom: 1px solid var(--border-color);
  display: flex;
  align-items: center;
  justify-content: space-between;
  background-color: var(--background-primary);
}

.header h1 {
  font-size: 20px;
  font-weight: 600;
  margin: 0;
  color: var(--text-primary);
}

.folder-info {
  display: flex;
  align-items: center;
  gap: 16px;
}

.selected-folder {
  padding: 6px 12px;
  border-radius: 4px;
  background-color: var(--hover-color);
  max-width: 300px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  color: var(--text-secondary);
}

.select-folder-btn {
  background-color: var(--background-primary);
  border: 1px solid var(--border-color);
  color: var(--text-primary);
  padding: 8px 16px;
  font-weight: 500;
}

.select-folder-btn:hover {
  background-color: var(--hover-color);
}

.main-content {
  display: flex;
  flex: 1;
  overflow: hidden;
  height: 100%;
}

.sidebar {
  width: 300px;
  min-width: 200px;
  max-width: 500px;
  height: 100%;
  display: flex;
  flex-direction: column;
  border-right: 1px solid var(--border-color);
  overflow: hidden;
  background-color: var(--background-secondary);
  position: relative;
  transition: width 0.1s ease;
}

.sidebar-header {
  padding: 16px;
  border-bottom: 1px solid var(--border-color);
  background-color: var(--background-secondary);
}

.sidebar-title {
  font-size: 18px;
  font-weight: 600;
  margin-bottom: 8px;
  color: var(--text-primary);
}

.sidebar-folder-path {
  font-size: 12px;
  color: var(--text-secondary);
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.sidebar-search {
  padding: 12px 16px;
  border-bottom: 1px solid var(--border-color);
  background-color: var(--background-secondary);
}

.sidebar-actions {
  display: flex;
  padding: 12px 16px;
  gap: 8px;
  border-bottom: 1px solid var(--border-color);
  background-color: var(--background-secondary);
}

.sidebar-action-btn {
  flex: 1;
  font-size: 13px;
  padding: 6px 12px;
  background-color: var(--background-primary);
  color: var(--text-primary);
  border: 1px solid var(--border-color);
}

.file-tree {
  flex: 1;
  overflow-y: auto;
  padding: 8px 0;
  background-color: var(--background-secondary);
}

.tree-empty {
  padding: 16px;
  text-align: center;
  color: var(--text-secondary);
  font-size: 14px;
}

.tree-loading {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 24px 16px;
  gap: 12px;
  color: var(--text-secondary);
}

.tree-loading .spinner {
  width: 24px;
  height: 24px;
}

.tree-item {
  display: flex;
  align-items: center;
  padding: 6px 8px;
  margin: 2px 0;
  border-radius: 4px;
  cursor: pointer;
  user-select: none;
  position: relative;
  transition: background-color 0.1s ease;
  color: var(--text-primary);
}

.tree-item:hover {
  background-color: var(--hover-color);
}

.tree-item.selected {
  background-color: var(--background-selected);
}

.tree-item-icon {
  margin-right: 8px;
  flex-shrink: 0;
  color: var(--icon-color);
}

.tree-item-content {
  display: flex;
  align-items: center;
  flex: 1;
  min-width: 0;
  overflow: hidden;
}

.tree-item-toggle {
  width: 20px;
  height: 20px;
  display: flex;
  align-items: center;
  justify-content: center;
  margin-right: 4px;
  cursor: pointer;
  color: var(--icon-color);
  z-index: 2;
}

.tree-item-toggle svg {
  transition: transform 0.15s ease-in-out;
  transform: rotate(0deg);
}

.tree-item-toggle.expanded svg {
  transform: rotate(90deg);
}

.tree-item-indent {
  width: 16px;
  flex-shrink: 0;
}

.tree-item-checkbox {
  margin-right: 8px;
  cursor: pointer;
}

.tree-item-name {
  flex: 1;
  min-width: 0;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  color: var(--text-primary);
}

.tree-item-tokens {
  font-size: 11px;
  color: var(--text-secondary);
  margin-left: 6px;
  white-space: nowrap;
}

.tree-item-badge {
  font-size: 10px;
  padding: 1px 5px;
  border-radius: 4px;
  background-color: var(--hover-color);
  color: var(--text-secondary);
  margin-left: 6px;
  white-space: nowrap;
}

.content-area {
  flex: 1;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  background-color: var(--background-primary);
  min-width: 0;
}

.content-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 16px 24px;
  border-bottom: 1px solid var(--border-color);
  background-color: var(--background-primary);
}

.content-title {
  font-size: 18px;
  font-weight: 600;
  color: var(--text-primary);
}

.content-actions {
  display: flex;
  align-items: center;
  gap: 16px;
}

.sort-dropdown {
  position: relative;
}

.sort-dropdown-button {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 14px;
  color: var(--text-primary);
}

.sort-options {
  position: absolute;
  top: calc(100% + 4px);
  right: 0;
  background-color: var(--background-primary);
  border: 1px solid var(--border-color);
  border-radius: 4px;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
  z-index: 100;
  min-width: 180px;
}

.sort-option {
  padding: 8px 16px;
  cursor: pointer;
  transition: background-color 0.2s;
  color: var(--text-primary);
}

.sort-option:hover {
  background-color: var(--hover-color);
}

.sort-option.active {
  background-color: var(--background-selected);
  font-weight: 600;
  color: var(--accent-blue);
}

.file-stats {
  font-size: 14px;
  color: var(--text-secondary);
}

.file-list-container {
  flex: 1;
  overflow: hidden;
  display: flex;
  flex-direction: column;
}

.file-list {
  flex: 1;
  overflow-y: auto;
  padding: 16px;
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
  grid-auto-rows: max-content;
  align-content: start;
  gap: 12px;
  background-color: var(--background-primary);
}

.file-list-empty {
  display: flex;
  align-items: center;
  justify-content: center;
  height: 100%;
  color: var(--text-secondary);
  font-size: 16px;
  padding: 32px;
  text-align: center;
}

.file-card {
  display: flex;
  flex-direction: column;
  padding: 10px;
  border: 1px solid var(--border-color);
  border-radius: 4px;
  position: relative;
  transition: all 0.2s ease;
  height: 80px;
  background-color: var(--background-primary);
}

.file-card:hover {
  background-color: var(--hover-color);
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
}

.file-card.selected {
  border: 2px solid var(--accent-blue);
  background-color: var(--background-selected);
}

.file-card-header {
  display: flex;
  align-items: center;
  margin-bottom: 8px;
}

.file-card-icon {
  margin-right: 8px;
  color: var(--icon-color);
  flex-shrink: 0;
}

.file-card-name {
  font-weight: 500;
  flex: 1;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  color: var(--text-primary);
}

.file-card-info {
  display: flex;
  flex-direction: column;
  margin-bottom: 0;
}

.file-card-tokens {
  color: var(--text-secondary);
  font-size: 13px;
}

.file-card-status {
  font-size: 13px;
  color: var(--text-secondary);
}

.file-card-actions {
  position: absolute;
  top: 8px;
  right: 8px;
  display: flex;
  gap: 4px;
  opacity: 0;
  transition: opacity 0.2s ease;
}

.file-card:hover .file-card-actions {
  opacity: 1;
}

.file-card-action {
  width: 24px;
  height: 24px;
  padding: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  background-color: var(--background-primary);
  border: 1px solid var(--border-color);
  border-radius: 4px;
  color: var(--icon-color);
  transition: all 0.15s ease;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
}

.file-card-action:hover {
  background-color: var(--hover-color);
  color: var(--accent-blue);
  border-color: var(--accent-blue);
  transform: translateY(-1px);
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.file-card-action:active {
  transform: translateY(0);
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
}

.copy-button-container {
  padding: 16px 24px;
  border-top: 1px solid var(--border-color);
  display: flex;
  justify-content: center;
  align-items: center;
  background-color: var(--background-primary);
}

.copy-button {
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 10px 16px;
  font-weight: 600;
  border-radius: 4px;
  transition: all 0.2s ease;
  gap: 8px;
  border: none;
  cursor: pointer;
  color: var(--primary-button-text);
  background-color: var(--primary-button-background);
}

.copy-button.primary {
  background-color: var(--primary-button-background);
  color: var(--primary-button-text);
  border: none;
}

.copy-button.primary:hover:not(:disabled) {
  background-color: var(--primary-button-background);
}

.copy-button.full-width {
  width: 100%;
  max-width: 400px;
}

.copy-button.copied {
  background-color: var(--success-color) !important;
  border-color: var(--success-color) !important;
  color: white !important;
  transition: all 0.2s ease;
  animation: flash-success 0.3s;
}

@keyframes flash-success {
  0% {
    opacity: 0.7;
  }
  50% {
    opacity: 1;
  }
  100% {
    opacity: 0.9;
  }
}

.copy-button-text {
  font-size: 14px;
  letter-spacing: 0.5px;
}

.copy-status {
  opacity: 0;
  transition: opacity 0.3s ease;
  color: var(--success-color);
  font-weight: 500;
}

.copy-status.visible {
  opacity: 1;
}

.processing-indicator {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 12px;
  padding: 12px;
  background-color: var(--background-secondary);
  border-bottom: 1px solid var(--border-color);
}

.spinner {
  width: 20px;
  height: 20px;
  border: 2px solid var(--text-secondary);
  border-top-color: transparent;
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  to {
    transform: rotate(360deg);
  }
}

.cancel-btn {
  padding: 4px 12px;
  font-size: 13px;
  background-color: var(--error-color);
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  transition: opacity 0.2s ease;
}

.cancel-btn:hover {
  opacity: 0.9;
}

.error-message {
  background-color: var(--error-color);
  color: white;
  padding: 16px 24px;
  border-radius: 4px;
  margin: 24px;
  display: flex;
  align-items: center;
  gap: 8px;
}

.tree-loading,
.empty-tree,
.empty-list {
  padding: 16px;
  text-align: center;
  color: var(--text-secondary);
  font-style: italic;
}

.search-bar {
  position: relative;
  display: flex;
  align-items: center;
  width: 100%;
  background-color: var(--background-primary);
  border: 1px solid var(--border-color);
  border-radius: 4px;
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
  transition: border-color 0.2s, box-shadow 0.2s;
}

.search-bar.focused {
  border-color: var(--accent-blue);
  box-shadow: 0 0 0 1px var(--accent-blue);
}

.search-icon {
  position: absolute;
  left: 10px;
  top: 50%;
  transform: translateY(-50%);
  color: var(--icon-color);
  display: flex;
  align-items: center;
  justify-content: center;
  pointer-events: none;
  z-index: 2;
  width: 16px;
  height: 16px;
}

.search-bar .search-input,
input[type="search"].search-input,
input[type="text"].search-input {
  width: 100%;
  padding: 8px 32px 8px 36px !important;
  border: none;
  border-radius: 4px;
  font-size: 14px;
  outline: none;
  background-color: transparent;
  color: var(--text-primary);
}

.search-bar .search-input:focus,
input[type="search"].search-input:focus,
input[type="text"].search-input:focus {
  border-color: var(--accent-blue);
  box-shadow: 0 0 0 1px var(--accent-blue);
}

.search-clear-btn {
  position: absolute;
  right: 8px;
  top: 50%;
  transform: translateY(-50%);
  background: none;
  border: none;
  padding: 4px;
  color: var(--icon-color);
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 50%;
  cursor: pointer;
  z-index: 2;
}

.search-clear-btn:hover {
  background-color: var(--hover-color);
}

.sidebar-resize-handle {
  position: absolute;
  top: 0;
  right: -5px;
  width: 10px;
  height: 100%;
  cursor: col-resize;
  z-index: 10;
  opacity: 0;
}

.sidebar-resize-handle:hover,
.sidebar-resize-handle:active {
  opacity: 1;
  background-color: rgba(0, 0, 0, 0.1);
}

.selected-folder {
  font-size: 14px;
  color: var(--text-secondary);
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  max-width: 500px;
  display: inline-block;
}

/* macOS-style segmented control for theme toggle */
.theme-segmented-control {
  display: flex;
  background-color: var(--background-secondary);
  border-radius: 6px;
  padding: 2px;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  width: fit-content;
  position: relative;
  height: 32px;
  overflow: hidden;
}

.theme-segment {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 6px;
  padding: 0 12px;
  height: 28px;
  border: none;
  background: none;
  font-size: 13px;
  font-weight: 500;
  color: var(--text-secondary);
  position: relative;
  z-index: 1;
  transition: color 0.2s ease;
  border-radius: 4px;
  cursor: pointer;
  white-space: nowrap;
  min-width: 70px;
}

.theme-segment:focus {
  outline: none;
}

.theme-segment span {
  font-size: 12px;
}

.theme-segment.active {
  color: var(--text-primary);
  background-color: var(--background-primary);
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
}

/* For dark mode, adjust active segment appearance */
.dark-mode .theme-segment.active {
  background-color: rgba(255, 255, 255, 0.1);
}

/* Animation for segment transition */
.theme-segment {
  transition: background-color 0.2s ease, color 0.2s ease, box-shadow 0.2s ease;
}

.header-actions {
  display: flex;
  align-items: center;
  gap: 16px;
}
</file>

<file path="src/App.tsx">
import React, { useState, useEffect, useCallback } from "react";
import Sidebar from "./components/Sidebar";
import FileList from "./components/FileList";
import CopyButton from "./components/CopyButton";
import { FileData } from "./types/FileTypes";
import { ThemeProvider } from "./context/ThemeContext";
import ThemeToggle from "./components/ThemeToggle";
import { generateAsciiFileTree, normalizePath, arePathsEqual } from "./utils/pathUtils";

// Access the electron API from the window object
declare global {
  interface Window {
    electron: {
      ipcRenderer: {
        send: (channel: string, data?: any) => void;
        on: (channel: string, func: (...args: any[]) => void) => void;
        removeListener: (
          channel: string,
          func: (...args: any[]) => void,
        ) => void;
      };
    };
  }
}

// Keys for localStorage
const STORAGE_KEYS = {
  SELECTED_FOLDER: "pastemax-selected-folder",
  SELECTED_FILES: "pastemax-selected-files",
  SORT_ORDER: "pastemax-sort-order",
  SEARCH_TERM: "pastemax-search-term",
  EXPANDED_NODES: "pastemax-expanded-nodes",
};

const App = (): JSX.Element => {
  // Clear saved folder on startup (temporary, for testing)
  useEffect(() => {
    localStorage.removeItem(STORAGE_KEYS.SELECTED_FOLDER);
    localStorage.removeItem("hasLoadedInitialData");
    sessionStorage.removeItem("hasLoadedInitialData");
  }, []);

  // Load initial state from localStorage if available
  const savedFolder = localStorage.getItem(STORAGE_KEYS.SELECTED_FOLDER);
  const savedFiles = localStorage.getItem(STORAGE_KEYS.SELECTED_FILES);
  const savedSortOrder = localStorage.getItem(STORAGE_KEYS.SORT_ORDER);
  const savedSearchTerm = localStorage.getItem(STORAGE_KEYS.SEARCH_TERM);

  const [selectedFolder, setSelectedFolder] = useState(
    savedFolder as string | null
  );
  const [allFiles, setAllFiles] = useState([] as FileData[]);
  const [selectedFiles, setSelectedFiles] = useState(
    savedFiles ? JSON.parse(savedFiles) : [] as string[]
  );
  const [sortOrder, setSortOrder] = useState(
    savedSortOrder || "tokens-desc"
  );
  const [searchTerm, setSearchTerm] = useState(savedSearchTerm || "");
  const [expandedNodes, setExpandedNodes] = useState(
    {} as Record<string, boolean>
  );
  const [displayedFiles, setDisplayedFiles] = useState([] as FileData[]);
  const [processingStatus, setProcessingStatus] = useState(
    { status: "idle", message: "" } as {
      status: "idle" | "processing" | "complete" | "error";
      message: string;
    }
  );
  const [includeFileTree, setIncludeFileTree] = useState(false);
  


  // State for sort dropdown
  const [sortDropdownOpen, setSortDropdownOpen] = useState(false);

  // Check if we're running in Electron or browser environment
  const isElectron = window.electron !== undefined;

  const [isSafeMode, setIsSafeMode] = useState(false);

  // Load expanded nodes state from localStorage
  useEffect(() => {
    const savedExpandedNodes = localStorage.getItem(
      STORAGE_KEYS.EXPANDED_NODES,
    );
    if (savedExpandedNodes) {
      try {
        setExpandedNodes(JSON.parse(savedExpandedNodes));
      } catch (error) {
        console.error("Error parsing saved expanded nodes:", error);
      }
    }
  }, []);

  // Persist selected folder when it changes
  useEffect(() => {
    if (selectedFolder) {
      localStorage.setItem(STORAGE_KEYS.SELECTED_FOLDER, selectedFolder);
    } else {
      localStorage.removeItem(STORAGE_KEYS.SELECTED_FOLDER);
    }
  }, [selectedFolder]);

  // Persist selected files when they change
  useEffect(() => {
    localStorage.setItem(
      STORAGE_KEYS.SELECTED_FILES,
      JSON.stringify(selectedFiles),
    );
  }, [selectedFiles]);

  // Persist sort order when it changes
  useEffect(() => {
    localStorage.setItem(STORAGE_KEYS.SORT_ORDER, sortOrder);
  }, [sortOrder]);

  // Persist search term when it changes
  useEffect(() => {
    localStorage.setItem(STORAGE_KEYS.SEARCH_TERM, searchTerm);
  }, [searchTerm]);

  // Add a function to cancel directory loading
  const cancelDirectoryLoading = useCallback(() => {
    if (isElectron) {
      window.electron.ipcRenderer.send("cancel-directory-loading");
      setProcessingStatus({
        status: "idle",
        message: "Directory loading cancelled",
      });
    }
  }, [isElectron]);

  // Add this new useEffect for safe mode detection
  useEffect(() => {
    if (!isElectron) return;
    
    const handleStartupMode = (mode: { safeMode: boolean }) => {
      setIsSafeMode(mode.safeMode);
    
      // If we're in safe mode, don't auto-load the previously selected folder
      if (mode.safeMode) {
        console.log("Starting in safe mode - not loading saved folder");
        localStorage.removeItem("hasLoadedInitialData");
        localStorage.removeItem(STORAGE_KEYS.SELECTED_FOLDER);
      }
    };
    
    window.electron.ipcRenderer.on("startup-mode", handleStartupMode);
    
    return () => {
      window.electron.ipcRenderer.removeListener("startup-mode", handleStartupMode);
    };
  }, [isElectron]);

  // Modify the existing useEffect for loading initial data
  useEffect(() => {
    // Temporarily disable auto-loading to test our changes
    return;
    
    /* Commented out for testing
    if (!isElectron || !selectedFolder || isSafeMode) return;
    
    // Use a flag in sessionStorage to ensure we only load data once per session
    const hasLoadedInitialData = sessionStorage.getItem("hasLoadedInitialData");
    if (hasLoadedInitialData === "true") return;
    
    console.log("Loading saved folder on startup:", selectedFolder);
    setProcessingStatus({
      status: "processing",
      message: "Loading files from previously selected folder... (Press ESC to cancel)",
    });
    window.electron.ipcRenderer.send("request-file-list", selectedFolder);
    
    // Mark that we've loaded the initial data
    sessionStorage.setItem("hasLoadedInitialData", "true");
    */
  }, [isElectron, selectedFolder, isSafeMode]);
  


  // Listen for folder selection from main process
  useEffect(() => {
    if (!isElectron) {
      console.warn("Not running in Electron environment");
      return;
    }

    const handleFolderSelected = (folderPath: string) => {
      // Check if folderPath is valid string
      if (typeof folderPath === "string") {
        console.log("Folder selected:", folderPath);
        setSelectedFolder(folderPath);
        // We'll select all files after they're loaded
        setSelectedFiles([]);
        setProcessingStatus({
          status: "processing",
          message: "Requesting file list...",
        });
        window.electron.ipcRenderer.send("request-file-list", folderPath);
      } else {
        console.error("Invalid folder path received:", folderPath);
        setProcessingStatus({
          status: "error",
          message: "Invalid folder path received",
        });
      }
    };

    const handleFileListData = (files: FileData[]) => {
      console.log("Received file list data:", files.length, "files");
      setAllFiles(files);
      setProcessingStatus({
        status: "complete",
        message: `Loaded ${files.length} files`,
      });

      // Apply filters and sort to the new files
      applyFiltersAndSort(files, sortOrder, searchTerm);

      // Select only files that are not binary, not skipped, and not excluded by default
      const selectablePaths = files
        .filter(
          (file: FileData) =>
            !file.isBinary && !file.isSkipped && !file.excludedByDefault, // Respect the excludedByDefault flag
        )
        .map((file: FileData) => file.path);

      setSelectedFiles(selectablePaths);
    };

    const handleProcessingStatus = (status: {
      status: "idle" | "processing" | "complete" | "error";
      message: string;
    }) => {
      console.log("Processing status:", status);
      setProcessingStatus(status);
    };

    window.electron.ipcRenderer.on("folder-selected", handleFolderSelected);
    window.electron.ipcRenderer.on("file-list-data", handleFileListData);
    window.electron.ipcRenderer.on(
      "file-processing-status",
      handleProcessingStatus,
    );

    return () => {
      window.electron.ipcRenderer.removeListener(
        "folder-selected",
        handleFolderSelected,
      );
      window.electron.ipcRenderer.removeListener(
        "file-list-data",
        handleFileListData,
      );
      window.electron.ipcRenderer.removeListener(
        "file-processing-status",
        handleProcessingStatus,
      );
    };
  }, [isElectron, sortOrder, searchTerm]);

  const openFolder = () => {
    if (isElectron) {
      console.log("Opening folder dialog");
      setProcessingStatus({ status: "idle", message: "Select a folder..." });
      window.electron.ipcRenderer.send("open-folder");
    } else {
      console.warn("Folder selection not available in browser");
    }
  };

  // Apply filters and sorting to files
  const applyFiltersAndSort = (
    files: FileData[],
    sort: string,
    filter: string,
  ) => {
    let filtered = files;

    // Apply filter
    if (filter) {
      const lowerFilter = filter.toLowerCase();
      filtered = files.filter(
        (file) =>
          file.name.toLowerCase().includes(lowerFilter) ||
          file.path.toLowerCase().includes(lowerFilter),
      );
    }

    // Apply sort
    const [sortKey, sortDir] = sort.split("-");
    const sorted = [...filtered].sort((a, b) => {
      let comparison = 0;

      if (sortKey === "name") {
        comparison = a.name.localeCompare(b.name);
      } else if (sortKey === "tokens") {
        comparison = a.tokenCount - b.tokenCount;
      } else if (sortKey === "size") {
        comparison = a.size - b.size;
      }

      return sortDir === "asc" ? comparison : -comparison;
    });

    setDisplayedFiles(sorted);
  };

  // Toggle file selection
  const toggleFileSelection = (filePath: string) => {
    // Normalize the incoming file path to handle cross-platform issues
    const normalizedPath = normalizePath(filePath);
    
    setSelectedFiles((prev: string[]) => {
      // Check if the file is already selected
      const isSelected = prev.some(path => arePathsEqual(path, normalizedPath));
      
      if (isSelected) {
        // Remove the file from selected files
        const newSelection = prev.filter((path: string) => !arePathsEqual(path, normalizedPath));
        return newSelection;
      } else {
        // Add the file to selected files
        const newSelection = [...prev, normalizedPath];
        return newSelection;
      }
    });
  };

  // Toggle folder selection (select/deselect all files in folder)
  const toggleFolderSelection = (folderPath: string, isSelected: boolean) => {
    // Normalize the folder path
    const normalizedFolderPath = normalizePath(folderPath);
    
    const filesInFolder = allFiles.filter(
      (file: FileData) =>
        normalizePath(file.path).startsWith(normalizedFolderPath) && 
        !file.isBinary && 
        !file.isSkipped,
    );

    if (isSelected) {
      // Add all files from this folder that aren't already selected
      const filePaths = filesInFolder.map((file: FileData) => normalizePath(file.path));
      
      setSelectedFiles((prev: string[]) => {
        const newSelection = [...prev];
        filePaths.forEach((path: string) => {
          if (!newSelection.some(p => arePathsEqual(p, path))) {
            newSelection.push(path);
          }
        });
        return newSelection;
      });
    } else {
      // Remove all files from this folder
      setSelectedFiles((prev: string[]) => {
        const newSelection = prev.filter(
          (path: string) =>
            !filesInFolder.some((file: FileData) => arePathsEqual(normalizePath(file.path), path)),
        );
        return newSelection;
      });
    }
  };

  // Handle sort change
  const handleSortChange = (newSort: string) => {
    setSortOrder(newSort);
    applyFiltersAndSort(allFiles, newSort, searchTerm);
    setSortDropdownOpen(false); // Close dropdown after selection
  };

  // Handle search change
  const handleSearchChange = (newSearch: string) => {
    setSearchTerm(newSearch);
    applyFiltersAndSort(allFiles, sortOrder, newSearch);
  };

  // Toggle sort dropdown
  const toggleSortDropdown = () => {
    setSortDropdownOpen(!sortDropdownOpen);
  };

  // Calculate total tokens from selected files
  const calculateTotalTokens = () => {
    return selectedFiles.reduce((total: number, path: string) => {
      const file = allFiles.find((f: FileData) => f.path === path);
      return total + (file ? file.tokenCount : 0);
    }, 0);
  };

  // Concatenate selected files content for copying
  const getSelectedFilesContent = () => {
    // Sort selected files according to current sort order
    const [sortKey, sortDir] = sortOrder.split("-");
    const sortedSelected = allFiles
      .filter((file: FileData) => selectedFiles.includes(file.path))
      .sort((a: FileData, b: FileData) => {
        let comparison = 0;

        if (sortKey === "name") {
          comparison = a.name.localeCompare(b.name);
        } else if (sortKey === "tokens") {
          comparison = a.tokenCount - b.tokenCount;
        } else if (sortKey === "size") {
          comparison = a.size - b.size;
        }

        return sortDir === "asc" ? comparison : -comparison;
      });

    if (sortedSelected.length === 0) {
      return "No files selected.";
    }

    let concatenatedString = "";
    
    // Add ASCII file tree if enabled
    if (includeFileTree && selectedFolder) {
      const asciiTree = generateAsciiFileTree(sortedSelected, selectedFolder);
      concatenatedString += `<file_map>\n${selectedFolder}\n${asciiTree}\n</file_map>\n\n`;
    }
    
    sortedSelected.forEach((file: FileData) => {
      concatenatedString += `\n\n// ---- File: ${file.name} ----\n\n`;
      concatenatedString += file.content;
    });

    return concatenatedString;
  };

  // Handle select all files
  const selectAllFiles = () => {
    const selectablePaths = displayedFiles
      .filter((file: FileData) => !file.isBinary && !file.isSkipped)
      .map((file: FileData) => file.path);

    setSelectedFiles((prev: string[]) => {
      const newSelection = [...prev];
      selectablePaths.forEach((path: string) => {
        if (!newSelection.includes(path)) {
          newSelection.push(path);
        }
      });
      return newSelection;
    });
  };

  // Handle deselect all files
  const deselectAllFiles = () => {
    const displayedPaths = displayedFiles.map((file: FileData) => file.path);
    setSelectedFiles((prev: string[]) =>
      prev.filter((path: string) => !displayedPaths.includes(path)),
    );
  };

  // Sort options for the dropdown
  const sortOptions = [
    { value: "tokens-desc", label: "Tokens: High to Low" },
    { value: "tokens-asc", label: "Tokens: Low to High" },
    { value: "name-asc", label: "Name: A to Z" },
    { value: "name-desc", label: "Name: Z to A" },
  ];

  // Handle expand/collapse state changes
  const toggleExpanded = (nodeId: string) => {
    setExpandedNodes((prev: Record<string, boolean>) => {
      const newState = {
        ...prev,
        [nodeId]: prev[nodeId] === undefined ? false : !prev[nodeId],
      };

      // Save to localStorage
      localStorage.setItem(
        STORAGE_KEYS.EXPANDED_NODES,
        JSON.stringify(newState),
      );

      return newState;
    });
  };

  return (
    <ThemeProvider children={
      <div className="app-container">
        <header className="header">
          <h1>PasteMax</h1>
          <div className="header-actions">
            <ThemeToggle />
            <div className="folder-info">
              {selectedFolder ? (
                <div className="selected-folder">{selectedFolder}</div>
              ) : (
                <span>No folder selected</span>
              )}
              <button
                className="select-folder-btn"
                onClick={openFolder}
                disabled={processingStatus.status === "processing"}
              >
                Select Folder
              </button>
            </div>
          </div>
        </header>

        {processingStatus.status === "processing" && (
          <div className="processing-indicator">
            <div className="spinner"></div>
            <span>{processingStatus.message}</span>
            <button
              className="cancel-btn"
              onClick={cancelDirectoryLoading}
            >
              Cancel
            </button>
          </div>
        )}

        {processingStatus.status === "error" && (
          <div className="error-message">Error: {processingStatus.message}</div>
        )}

        {selectedFolder && (
          <div className="main-content">
            <Sidebar
              selectedFolder={selectedFolder}
              openFolder={openFolder}
              allFiles={allFiles}
              selectedFiles={selectedFiles}
              toggleFileSelection={toggleFileSelection}
              toggleFolderSelection={toggleFolderSelection}
              searchTerm={searchTerm}
              onSearchChange={handleSearchChange}
              selectAllFiles={selectAllFiles}
              deselectAllFiles={deselectAllFiles}
              expandedNodes={expandedNodes}
              toggleExpanded={toggleExpanded}
            />
            <div className="content-area">
              <div className="content-header">
                <div className="content-title">Selected Files</div>
                <div className="content-actions">
                  <div className="sort-dropdown">
                    <button
                      className="sort-dropdown-button"
                      onClick={toggleSortDropdown}
                    >
                      Sort:{" "}
                      {sortOptions.find((opt) => opt.value === sortOrder)
                        ?.label || sortOrder}
                    </button>
                    {sortDropdownOpen && (
                      <div className="sort-options">
                        {sortOptions.map((option) => (
                          <div
                            key={option.value}
                            className={`sort-option ${
                              sortOrder === option.value ? "active" : ""
                            }`}
                            onClick={() => handleSortChange(option.value)}
                          >
                            {option.label}
                          </div>
                        ))}
                      </div>
                    )}
                  </div>
                  <div className="file-stats">
                    {selectedFiles.length} files | ~
                    {calculateTotalTokens().toLocaleString()} tokens
                  </div>
                </div>
              </div>

              <FileList
                files={displayedFiles}
                selectedFiles={selectedFiles}
                toggleFileSelection={toggleFileSelection}
              />

              <div className="copy-button-container">
                <div style={{ display: "flex", flexDirection: "column", alignItems: "center", gap: "12px", width: "100%", maxWidth: "400px" }}>
                  <label style={{ display: "flex", alignItems: "center", gap: "8px", cursor: "pointer" }}>
                    <input
                      type="checkbox"
                      checked={includeFileTree}
                      onChange={() => setIncludeFileTree(!includeFileTree)}
                    />
                    <span>Include File Tree</span>
                  </label>
                  <CopyButton
                    text={getSelectedFilesContent()}
                    className="primary full-width"
                  >
                    <span>COPY ALL SELECTED ({selectedFiles.length} files)</span>
                  </CopyButton>
                </div>
              </div>
            </div>
          </div>
        )}
      </div>
    } />
  );
};

export default App;
</file>

</files>
